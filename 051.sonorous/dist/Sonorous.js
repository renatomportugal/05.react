(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Sonorous"] = factory();
	else
		root["Sonorous"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./Sonorous.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/axios-retry/index.js":
/*!********************************************!*\
  !*** ../node_modules/axios-retry/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/index */ \"../node_modules/axios-retry/lib/index.js\").default;\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios-retry/index.js?");

/***/ }),

/***/ "../node_modules/axios-retry/lib/index.js":
/*!************************************************!*\
  !*** ../node_modules/axios-retry/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNetworkError = isNetworkError;\nexports.isRetryableError = isRetryableError;\nexports.isSafeRequestError = isSafeRequestError;\nexports.isIdempotentRequestError = isIdempotentRequestError;\nexports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\nexports.exponentialDelay = exponentialDelay;\nexports.default = axiosRetry;\n\nvar _isRetryAllowed = __webpack_require__(/*! is-retry-allowed */ \"../node_modules/is-retry-allowed/index.js\");\n\nvar _isRetryAllowed2 = _interopRequireDefault(_isRetryAllowed);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar namespace = 'axios-retry';\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nfunction isNetworkError(error) {\n  return !error.response && Boolean(error.code) && // Prevents retrying cancelled requests\n  error.code !== 'ECONNABORTED' && // Prevents retrying timed out requests\n  (0, _isRetryAllowed2.default)(error); // Prevents retrying unsafe errors\n}\n\nvar SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nvar IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nfunction isRetryableError(error) {\n  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nfunction isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nfunction isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false;\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nfunction isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error);\n}\n\n/**\n * @return {number} - delay in milliseconds, always 0\n */\nfunction noDelay() {\n  return 0;\n}\n\n/**\n * @param  {number} [retryNumber=0]\n * @return {number} - delay in milliseconds\n */\nfunction exponentialDelay() {\n  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n  var delay = Math.pow(2, retryNumber) * 100;\n  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n  return delay + randomSum;\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @return {Object}\n */\nfunction getCurrentState(config) {\n  var currentState = config[namespace] || {};\n  currentState.retryCount = currentState.retryCount || 0;\n  config[namespace] = currentState;\n  return currentState;\n}\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {AxiosRetryConfig} defaultOptions\n * @return {AxiosRetryConfig}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return Object.assign({}, defaultOptions, config[namespace]);\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent;\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent;\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent;\n  }\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {boolean} [defaultOptions.shouldResetTimeout=false]\n *        Defines if the timeout should be reset between retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n */\nfunction axiosRetry(axios, defaultOptions) {\n  axios.interceptors.request.use(function (config) {\n    var currentState = getCurrentState(config);\n    currentState.lastRequestTime = Date.now();\n    return config;\n  });\n\n  axios.interceptors.response.use(null, function (error) {\n    var config = error.config;\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    var _getRequestOptions = getRequestOptions(config, defaultOptions),\n        _getRequestOptions$re = _getRequestOptions.retries,\n        retries = _getRequestOptions$re === undefined ? 3 : _getRequestOptions$re,\n        _getRequestOptions$re2 = _getRequestOptions.retryCondition,\n        retryCondition = _getRequestOptions$re2 === undefined ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2,\n        _getRequestOptions$re3 = _getRequestOptions.retryDelay,\n        retryDelay = _getRequestOptions$re3 === undefined ? noDelay : _getRequestOptions$re3,\n        _getRequestOptions$sh = _getRequestOptions.shouldResetTimeout,\n        shouldResetTimeout = _getRequestOptions$sh === undefined ? false : _getRequestOptions$sh;\n\n    var currentState = getCurrentState(config);\n\n    var shouldRetry = retryCondition(error) && currentState.retryCount < retries;\n\n    if (shouldRetry) {\n      currentState.retryCount += 1;\n      var delay = retryDelay(currentState.retryCount, error);\n\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axios, config);\n\n      if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        var lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)\n        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);\n      }\n\n      config.transformRequest = [function (data) {\n        return data;\n      }];\n\n      return new Promise(function (resolve) {\n        return setTimeout(function () {\n          return resolve(axios(config));\n        }, delay);\n      });\n    }\n\n    return Promise.reject(error);\n  });\n}\n\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.isRetryableError = isRetryableError;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios-retry/lib/index.js?");

/***/ }),

/***/ "../node_modules/axios/index.js":
/*!**************************************!*\
  !*** ../node_modules/axios/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"../node_modules/axios/lib/axios.js\");\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/index.js?");

/***/ }),

/***/ "../node_modules/axios/lib/adapters/xhr.js":
/*!*************************************************!*\
  !*** ../node_modules/axios/lib/adapters/xhr.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"../node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"../node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"../node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"../node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"../node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"../node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"../node_modules/axios/lib/core/createError.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "../node_modules/axios/lib/axios.js":
/*!******************************************!*\
  !*** ../node_modules/axios/lib/axios.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"../node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"../node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"../node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"../node_modules/axios/lib/defaults.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"../node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"../node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"../node_modules/axios/lib/cancel/isCancel.js\");\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"../node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"../node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "../node_modules/axios/lib/cancel/Cancel.js":
/*!**************************************************!*\
  !*** ../node_modules/axios/lib/cancel/Cancel.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/cancel/Cancel.js?");

/***/ }),

/***/ "../node_modules/axios/lib/cancel/CancelToken.js":
/*!*******************************************************!*\
  !*** ../node_modules/axios/lib/cancel/CancelToken.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"../node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "../node_modules/axios/lib/cancel/isCancel.js":
/*!****************************************************!*\
  !*** ../node_modules/axios/lib/cancel/isCancel.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/Axios.js":
/*!***********************************************!*\
  !*** ../node_modules/axios/lib/core/Axios.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"../node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"../node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"../node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"../node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"../node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/InterceptorManager.js":
/*!************************************************************!*\
  !*** ../node_modules/axios/lib/core/InterceptorManager.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/buildFullPath.js":
/*!*******************************************************!*\
  !*** ../node_modules/axios/lib/core/buildFullPath.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"../node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"../node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/buildFullPath.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/createError.js":
/*!*****************************************************!*\
  !*** ../node_modules/axios/lib/core/createError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"../node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/createError.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/dispatchRequest.js":
/*!*********************************************************!*\
  !*** ../node_modules/axios/lib/core/dispatchRequest.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"../node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"../node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"../node_modules/axios/lib/defaults.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/enhanceError.js":
/*!******************************************************!*\
  !*** ../node_modules/axios/lib/core/enhanceError.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/enhanceError.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/mergeConfig.js":
/*!*****************************************************!*\
  !*** ../node_modules/axios/lib/core/mergeConfig.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/mergeConfig.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/settle.js":
/*!************************************************!*\
  !*** ../node_modules/axios/lib/core/settle.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"../node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "../node_modules/axios/lib/core/transformData.js":
/*!*******************************************************!*\
  !*** ../node_modules/axios/lib/core/transformData.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ./../defaults */ \"../node_modules/axios/lib/defaults.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "../node_modules/axios/lib/defaults.js":
/*!*********************************************!*\
  !*** ../node_modules/axios/lib/defaults.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"../node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ./core/enhanceError */ \"../node_modules/axios/lib/core/enhanceError.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"../node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"../node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/defaults.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/bind.js":
/*!*************************************************!*\
  !*** ../node_modules/axios/lib/helpers/bind.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/buildURL.js":
/*!*****************************************************!*\
  !*** ../node_modules/axios/lib/helpers/buildURL.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/combineURLs.js":
/*!********************************************************!*\
  !*** ../node_modules/axios/lib/helpers/combineURLs.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/cookies.js":
/*!****************************************************!*\
  !*** ../node_modules/axios/lib/helpers/cookies.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!**********************************************************!*\
  !*** ../node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/isAxiosError.js":
/*!*********************************************************!*\
  !*** ../node_modules/axios/lib/helpers/isAxiosError.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/isAxiosError.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!************************************************************!*\
  !*** ../node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!****************************************************************!*\
  !*** ../node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"../node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/parseHeaders.js":
/*!*********************************************************!*\
  !*** ../node_modules/axios/lib/helpers/parseHeaders.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"../node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/spread.js":
/*!***************************************************!*\
  !*** ../node_modules/axios/lib/helpers/spread.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "../node_modules/axios/lib/helpers/validator.js":
/*!******************************************************!*\
  !*** ../node_modules/axios/lib/helpers/validator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar pkg = __webpack_require__(/*! ./../../package.json */ \"../node_modules/axios/package.json\");\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\nvar currentVerArr = pkg.version.split('.');\n\n/**\n * Compare package versions\n * @param {string} version\n * @param {string?} thanVersion\n * @returns {boolean}\n */\nfunction isOlderVersion(version, thanVersion) {\n  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;\n  var destVer = version.split('.');\n  for (var i = 0; i < 3; i++) {\n    if (pkgVersionArr[i] > destVer[i]) {\n      return true;\n    } else if (pkgVersionArr[i] < destVer[i]) {\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator\n * @param {string?} version\n * @param {string} message\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  var isDeprecated = version && isOlderVersion(version);\n\n  function formatMessage(opt, desc) {\n    return '[Axios v' + pkg.version + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed in ' + version));\n    }\n\n    if (isDeprecated && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  isOlderVersion: isOlderVersion,\n  assertOptions: assertOptions,\n  validators: validators\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/helpers/validator.js?");

/***/ }),

/***/ "../node_modules/axios/lib/utils.js":
/*!******************************************!*\
  !*** ../node_modules/axios/lib/utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"../node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "../node_modules/axios/package.json":
/*!******************************************!*\
  !*** ../node_modules/axios/package.json ***!
  \******************************************/
/*! exports provided: name, version, description, main, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, browser, jsdelivr, unpkg, typings, dependencies, bundlesize, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"axios\\\",\\\"version\\\":\\\"0.21.4\\\",\\\"description\\\":\\\"Promise based HTTP client for the browser and node.js\\\",\\\"main\\\":\\\"index.js\\\",\\\"scripts\\\":{\\\"test\\\":\\\"grunt test\\\",\\\"start\\\":\\\"node ./sandbox/server.js\\\",\\\"build\\\":\\\"NODE_ENV=production grunt build\\\",\\\"preversion\\\":\\\"npm test\\\",\\\"version\\\":\\\"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json\\\",\\\"postversion\\\":\\\"git push && git push --tags\\\",\\\"examples\\\":\\\"node ./examples/server.js\\\",\\\"coveralls\\\":\\\"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js\\\",\\\"fix\\\":\\\"eslint --fix lib/**/*.js\\\"},\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"https://github.com/axios/axios.git\\\"},\\\"keywords\\\":[\\\"xhr\\\",\\\"http\\\",\\\"ajax\\\",\\\"promise\\\",\\\"node\\\"],\\\"author\\\":\\\"Matt Zabriskie\\\",\\\"license\\\":\\\"MIT\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/axios/axios/issues\\\"},\\\"homepage\\\":\\\"https://axios-http.com\\\",\\\"devDependencies\\\":{\\\"coveralls\\\":\\\"^3.0.0\\\",\\\"es6-promise\\\":\\\"^4.2.4\\\",\\\"grunt\\\":\\\"^1.3.0\\\",\\\"grunt-banner\\\":\\\"^0.6.0\\\",\\\"grunt-cli\\\":\\\"^1.2.0\\\",\\\"grunt-contrib-clean\\\":\\\"^1.1.0\\\",\\\"grunt-contrib-watch\\\":\\\"^1.0.0\\\",\\\"grunt-eslint\\\":\\\"^23.0.0\\\",\\\"grunt-karma\\\":\\\"^4.0.0\\\",\\\"grunt-mocha-test\\\":\\\"^0.13.3\\\",\\\"grunt-ts\\\":\\\"^6.0.0-beta.19\\\",\\\"grunt-webpack\\\":\\\"^4.0.2\\\",\\\"istanbul-instrumenter-loader\\\":\\\"^1.0.0\\\",\\\"jasmine-core\\\":\\\"^2.4.1\\\",\\\"karma\\\":\\\"^6.3.2\\\",\\\"karma-chrome-launcher\\\":\\\"^3.1.0\\\",\\\"karma-firefox-launcher\\\":\\\"^2.1.0\\\",\\\"karma-jasmine\\\":\\\"^1.1.1\\\",\\\"karma-jasmine-ajax\\\":\\\"^0.1.13\\\",\\\"karma-safari-launcher\\\":\\\"^1.0.0\\\",\\\"karma-sauce-launcher\\\":\\\"^4.3.6\\\",\\\"karma-sinon\\\":\\\"^1.0.5\\\",\\\"karma-sourcemap-loader\\\":\\\"^0.3.8\\\",\\\"karma-webpack\\\":\\\"^4.0.2\\\",\\\"load-grunt-tasks\\\":\\\"^3.5.2\\\",\\\"minimist\\\":\\\"^1.2.0\\\",\\\"mocha\\\":\\\"^8.2.1\\\",\\\"sinon\\\":\\\"^4.5.0\\\",\\\"terser-webpack-plugin\\\":\\\"^4.2.3\\\",\\\"typescript\\\":\\\"^4.0.5\\\",\\\"url-search-params\\\":\\\"^0.10.0\\\",\\\"webpack\\\":\\\"^4.44.2\\\",\\\"webpack-dev-server\\\":\\\"^3.11.0\\\"},\\\"browser\\\":{\\\"./lib/adapters/http.js\\\":\\\"./lib/adapters/xhr.js\\\"},\\\"jsdelivr\\\":\\\"dist/axios.min.js\\\",\\\"unpkg\\\":\\\"dist/axios.min.js\\\",\\\"typings\\\":\\\"./index.d.ts\\\",\\\"dependencies\\\":{\\\"follow-redirects\\\":\\\"^1.14.0\\\"},\\\"bundlesize\\\":[{\\\"path\\\":\\\"./dist/axios.min.js\\\",\\\"threshold\\\":\\\"5kB\\\"}]}\");\n\n//# sourceURL=webpack://Sonorous/../node_modules/axios/package.json?");

/***/ }),

/***/ "../node_modules/eventemitter3/index.js":
/*!**********************************************!*\
  !*** ../node_modules/eventemitter3/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "../node_modules/is-retry-allowed/index.js":
/*!*************************************************!*\
  !*** ../node_modules/is-retry-allowed/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar WHITELIST = [\n\t'ETIMEDOUT',\n\t'ECONNRESET',\n\t'EADDRINUSE',\n\t'ESOCKETTIMEDOUT',\n\t'ECONNREFUSED',\n\t'EPIPE',\n\t'EHOSTUNREACH',\n\t'EAI_AGAIN'\n];\n\nvar BLACKLIST = [\n\t'ENOTFOUND',\n\t'ENETUNREACH',\n\n\t// SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950\n\t'UNABLE_TO_GET_ISSUER_CERT',\n\t'UNABLE_TO_GET_CRL',\n\t'UNABLE_TO_DECRYPT_CERT_SIGNATURE',\n\t'UNABLE_TO_DECRYPT_CRL_SIGNATURE',\n\t'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',\n\t'CERT_SIGNATURE_FAILURE',\n\t'CRL_SIGNATURE_FAILURE',\n\t'CERT_NOT_YET_VALID',\n\t'CERT_HAS_EXPIRED',\n\t'CRL_NOT_YET_VALID',\n\t'CRL_HAS_EXPIRED',\n\t'ERROR_IN_CERT_NOT_BEFORE_FIELD',\n\t'ERROR_IN_CERT_NOT_AFTER_FIELD',\n\t'ERROR_IN_CRL_LAST_UPDATE_FIELD',\n\t'ERROR_IN_CRL_NEXT_UPDATE_FIELD',\n\t'OUT_OF_MEM',\n\t'DEPTH_ZERO_SELF_SIGNED_CERT',\n\t'SELF_SIGNED_CERT_IN_CHAIN',\n\t'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',\n\t'UNABLE_TO_VERIFY_LEAF_SIGNATURE',\n\t'CERT_CHAIN_TOO_LONG',\n\t'CERT_REVOKED',\n\t'INVALID_CA',\n\t'PATH_LENGTH_EXCEEDED',\n\t'INVALID_PURPOSE',\n\t'CERT_UNTRUSTED',\n\t'CERT_REJECTED'\n];\n\nmodule.exports = function (err) {\n\tif (!err || !err.code) {\n\t\treturn true;\n\t}\n\n\tif (WHITELIST.indexOf(err.code) !== -1) {\n\t\treturn true;\n\t}\n\n\tif (BLACKLIST.indexOf(err.code) !== -1) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/is-retry-allowed/index.js?");

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/process/browser.js?");

/***/ }),

/***/ "../node_modules/ua-parser-js/src/ua-parser.js":
/*!*****************************************************!*\
  !*** ../node_modules/ua-parser-js/src/ua-parser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * UAParser.js v0.7.24\n * Lightweight JavaScript-based User-Agent string parser\n * https://github.com/faisalman/ua-parser-js\n *\n * Copyright © 2012-2021 Faisal Salman <f@faisalman.com>\n * Licensed under MIT License\n */\n\n(function (window, undefined) {\n\n    'use strict';\n\n    //////////////\n    // Constants\n    /////////////\n\n\n    var LIBVERSION  = '0.7.24',\n        EMPTY       = '',\n        UNKNOWN     = '?',\n        FUNC_TYPE   = 'function',\n        UNDEF_TYPE  = 'undefined',\n        OBJ_TYPE    = 'object',\n        STR_TYPE    = 'string',\n        MAJOR       = 'major', // deprecated\n        MODEL       = 'model',\n        NAME        = 'name',\n        TYPE        = 'type',\n        VENDOR      = 'vendor',\n        VERSION     = 'version',\n        ARCHITECTURE= 'architecture',\n        CONSOLE     = 'console',\n        MOBILE      = 'mobile',\n        TABLET      = 'tablet',\n        SMARTTV     = 'smarttv',\n        WEARABLE    = 'wearable',\n        EMBEDDED    = 'embedded';\n\n\n    ///////////\n    // Helper\n    //////////\n\n\n    var util = {\n        extend : function (regexes, extensions) {\n            var mergedRegexes = {};\n            for (var i in regexes) {\n                if (extensions[i] && extensions[i].length % 2 === 0) {\n                    mergedRegexes[i] = extensions[i].concat(regexes[i]);\n                } else {\n                    mergedRegexes[i] = regexes[i];\n                }\n            }\n            return mergedRegexes;\n        },\n        has : function (str1, str2) {\n          if (typeof str1 === \"string\") {\n            return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;\n          } else {\n            return false;\n          }\n        },\n        lowerize : function (str) {\n            return str.toLowerCase();\n        },\n        major : function (version) {\n            return typeof(version) === STR_TYPE ? version.replace(/[^\\d\\.]/g,'').split(\".\")[0] : undefined;\n        },\n        trim : function (str) {\n          return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n        }\n    };\n\n\n    ///////////////\n    // Map helper\n    //////////////\n\n\n    var mapper = {\n\n        rgx : function (ua, arrays) {\n\n            var i = 0, j, k, p, q, matches, match;\n\n            // loop through all regexes maps\n            while (i < arrays.length && !matches) {\n\n                var regex = arrays[i],       // even sequence (0,2,4,..)\n                    props = arrays[i + 1];   // odd sequence (1,3,5,..)\n                j = k = 0;\n\n                // try matching uastring with regexes\n                while (j < regex.length && !matches) {\n\n                    matches = regex[j++].exec(ua);\n\n                    if (!!matches) {\n                        for (p = 0; p < props.length; p++) {\n                            match = matches[++k];\n                            q = props[p];\n                            // check if given property is actually array\n                            if (typeof q === OBJ_TYPE && q.length > 0) {\n                                if (q.length == 2) {\n                                    if (typeof q[1] == FUNC_TYPE) {\n                                        // assign modified match\n                                        this[q[0]] = q[1].call(this, match);\n                                    } else {\n                                        // assign given value, ignore regex match\n                                        this[q[0]] = q[1];\n                                    }\n                                } else if (q.length == 3) {\n                                    // check whether function or regex\n                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {\n                                        // call function (usually string mapper)\n                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;\n                                    } else {\n                                        // sanitize match using given regex\n                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;\n                                    }\n                                } else if (q.length == 4) {\n                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;\n                                }\n                            } else {\n                                this[q] = match ? match : undefined;\n                            }\n                        }\n                    }\n                }\n                i += 2;\n            }\n        },\n\n        str : function (str, map) {\n\n            for (var i in map) {\n                // check if array\n                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {\n                    for (var j = 0; j < map[i].length; j++) {\n                        if (util.has(map[i][j], str)) {\n                            return (i === UNKNOWN) ? undefined : i;\n                        }\n                    }\n                } else if (util.has(map[i], str)) {\n                    return (i === UNKNOWN) ? undefined : i;\n                }\n            }\n            return str;\n        }\n    };\n\n\n    ///////////////\n    // String map\n    //////////////\n\n\n    var maps = {\n\n        browser : {\n            oldsafari : {\n                version : {\n                    '1.0'   : '/8',\n                    '1.2'   : '/1',\n                    '1.3'   : '/3',\n                    '2.0'   : '/412',\n                    '2.0.2' : '/416',\n                    '2.0.3' : '/417',\n                    '2.0.4' : '/419',\n                    '?'     : '/'\n                }\n            }\n        },\n\n        device : {\n            amazon : {\n                model : {\n                    'Fire Phone' : ['SD', 'KF']\n                }\n            },\n            sprint : {\n                model : {\n                    'Evo Shift 4G' : '7373KT'\n                },\n                vendor : {\n                    'HTC'       : 'APA',\n                    'Sprint'    : 'Sprint'\n                }\n            }\n        },\n\n        os : {\n            windows : {\n                version : {\n                    'ME'        : '4.90',\n                    'NT 3.11'   : 'NT3.51',\n                    'NT 4.0'    : 'NT4.0',\n                    '2000'      : 'NT 5.0',\n                    'XP'        : ['NT 5.1', 'NT 5.2'],\n                    'Vista'     : 'NT 6.0',\n                    '7'         : 'NT 6.1',\n                    '8'         : 'NT 6.2',\n                    '8.1'       : 'NT 6.3',\n                    '10'        : ['NT 6.4', 'NT 10.0'],\n                    'RT'        : 'ARM'\n                }\n            }\n        }\n    };\n\n\n    //////////////\n    // Regex map\n    /////////////\n\n\n    var regexes = {\n\n        browser : [[\n\n            // Presto based\n            /(opera\\smini)\\/([\\w\\.-]+)/i,                                       // Opera Mini\n            /(opera\\s[mobiletab]{3,6}).+version\\/([\\w\\.-]+)/i,                  // Opera Mobi/Tablet\n            /(opera).+version\\/([\\w\\.]+)/i,                                     // Opera > 9.80\n            /(opera)[\\/\\s]+([\\w\\.]+)/i                                          // Opera < 9.80\n            ], [NAME, VERSION], [\n\n            /(opios)[\\/\\s]+([\\w\\.]+)/i                                          // Opera mini on iphone >= 8.0\n            ], [[NAME, 'Opera Mini'], VERSION], [\n\n            /\\s(opr)\\/([\\w\\.]+)/i                                               // Opera Webkit\n            ], [[NAME, 'Opera'], VERSION], [\n\n            // Mixed\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /(lunascape|maxthon|netfront|jasmine|blazer)[\\/\\s]?([\\w\\.]*)/i,\n                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer\n            // Trident based\n            /(avant\\s|iemobile|slim)(?:browser)?[\\/\\s]?([\\w\\.]*)/i,\n                                                                                // Avant/IEMobile/SlimBrowser\n            /(bidubrowser|baidubrowser)[\\/\\s]?([\\w\\.]+)/i,                      // Baidu Browser\n            /(?:ms|\\()(ie)\\s([\\w\\.]+)/i,                                        // Internet Explorer\n\n            // Webkit/KHTML based\n            /(rekonq)\\/([\\w\\.]*)/i,                                             // Rekonq\n            /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\\/([\\w\\.-]+)/i\n                                                                                // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon\n            ], [NAME, VERSION], [\n\n            /(konqueror)\\/([\\w\\.]+)/i                                           // Konqueror\n            ], [[NAME, 'Konqueror'], VERSION], [\n\n            /(trident).+rv[:\\s]([\\w\\.]{1,9}).+like\\sgecko/i                     // IE11\n            ], [[NAME, 'IE'], VERSION], [\n\n            /(edge|edgios|edga|edg)\\/((\\d+)?[\\w\\.]+)/i                          // Microsoft Edge\n            ], [[NAME, 'Edge'], VERSION], [\n\n            /(yabrowser)\\/([\\w\\.]+)/i                                           // Yandex\n            ], [[NAME, 'Yandex'], VERSION], [\n\n            /(Avast)\\/([\\w\\.]+)/i                                               // Avast Secure Browser\n            ], [[NAME, 'Avast Secure Browser'], VERSION], [\n\n            /(AVG)\\/([\\w\\.]+)/i                                                 // AVG Secure Browser\n            ], [[NAME, 'AVG Secure Browser'], VERSION], [\n\n            /(puffin)\\/([\\w\\.]+)/i                                              // Puffin\n            ], [[NAME, 'Puffin'], VERSION], [\n\n            /(focus)\\/([\\w\\.]+)/i                                               // Firefox Focus\n            ], [[NAME, 'Firefox Focus'], VERSION], [\n\n            /(opt)\\/([\\w\\.]+)/i                                                 // Opera Touch\n            ], [[NAME, 'Opera Touch'], VERSION], [\n\n            /((?:[\\s\\/])uc?\\s?browser|(?:juc.+)ucweb)[\\/\\s]?([\\w\\.]+)/i         // UCBrowser\n            ], [[NAME, 'UCBrowser'], VERSION], [\n\n            /(comodo_dragon)\\/([\\w\\.]+)/i                                       // Comodo Dragon\n            ], [[NAME, /_/g, ' '], VERSION], [\n\n            /(windowswechat qbcore)\\/([\\w\\.]+)/i                                // WeChat Desktop for Windows Built-in Browser\n            ], [[NAME, 'WeChat(Win) Desktop'], VERSION], [\n\n            /(micromessenger)\\/([\\w\\.]+)/i                                      // WeChat\n            ], [[NAME, 'WeChat'], VERSION], [\n\n            /(brave)\\/([\\w\\.]+)/i                                               // Brave browser\n            ], [[NAME, 'Brave'], VERSION], [\n\n            /(whale)\\/([\\w\\.]+)/i                                               // Whale browser\n            ], [[NAME, 'Whale'], VERSION], [\n\n            /(qqbrowserlite)\\/([\\w\\.]+)/i                                       // QQBrowserLite\n            ], [NAME, VERSION], [\n\n            /(QQ)\\/([\\d\\.]+)/i                                                  // QQ, aka ShouQ\n            ], [NAME, VERSION], [\n\n            /m?(qqbrowser)[\\/\\s]?([\\w\\.]+)/i                                    // QQBrowser\n            ], [NAME, VERSION], [\n\n            /(baiduboxapp)[\\/\\s]?([\\w\\.]+)/i                                    // Baidu App\n            ], [NAME, VERSION], [\n\n            /(2345Explorer)[\\/\\s]?([\\w\\.]+)/i                                   // 2345 Browser\n            ], [NAME, VERSION], [\n\n            /(MetaSr)[\\/\\s]?([\\w\\.]+)/i                                         // SouGouBrowser\n            ], [NAME], [\n\n            /(LBBROWSER)/i                                                      // LieBao Browser\n            ], [NAME], [\n\n            /xiaomi\\/miuibrowser\\/([\\w\\.]+)/i                                   // MIUI Browser\n            ], [VERSION, [NAME, 'MIUI Browser']], [\n\n            /;fbav\\/([\\w\\.]+);/i                                                // Facebook App for iOS & Android with version\n            ], [VERSION, [NAME, 'Facebook']], [\n            \n            /FBAN\\/FBIOS|FB_IAB\\/FB4A/i                                         // Facebook App for iOS & Android without version\n            ], [[NAME, 'Facebook']], [\n\n            /safari\\s(line)\\/([\\w\\.]+)/i,                                       // Line App for iOS\n            /android.+(line)\\/([\\w\\.]+)\\/iab/i                                  // Line App for Android\n            ], [NAME, VERSION], [\n\n            /headlesschrome(?:\\/([\\w\\.]+)|\\s)/i                                 // Chrome Headless\n            ], [VERSION, [NAME, 'Chrome Headless']], [\n\n            /\\swv\\).+(chrome)\\/([\\w\\.]+)/i                                      // Chrome WebView\n            ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [\n\n            /((?:oculus|samsung)browser)\\/([\\w\\.]+)/i\n            ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser\n\n            /android.+version\\/([\\w\\.]+)\\s+(?:mobile\\s?safari|safari)*/i        // Android Browser\n            ], [VERSION, [NAME, 'Android Browser']], [\n\n            /(coc_coc_browser)\\/([\\w\\.]+)/i                                     // Coc Coc Browser\n            ], [[NAME, 'Coc Coc'], VERSION], [\n\n              /(sailfishbrowser)\\/([\\w\\.]+)/i                                     // Sailfish Browser\n            ], [[NAME, 'Sailfish Browser'], VERSION], [\n\n            /(chrome|omniweb|arora|[tizenoka]{5}\\s?browser)\\/v?([\\w\\.]+)/i\n                                                                                // Chrome/OmniWeb/Arora/Tizen/Nokia\n            ], [NAME, VERSION], [\n\n            /(dolfin)\\/([\\w\\.]+)/i                                              // Dolphin\n            ], [[NAME, 'Dolphin'], VERSION], [\n\n            /(qihu|qhbrowser|qihoobrowser|360browser)/i                         // 360\n            ], [[NAME, '360 Browser']], [\n\n            /((?:android.+)crmo|crios)\\/([\\w\\.]+)/i                             // Chrome for Android/iOS\n            ], [[NAME, 'Chrome'], VERSION], [\n\n            /(coast)\\/([\\w\\.]+)/i                                               // Opera Coast\n            ], [[NAME, 'Opera Coast'], VERSION], [\n\n            /fxios\\/([\\w\\.-]+)/i                                                // Firefox for iOS\n            ], [VERSION, [NAME, 'Firefox']], [\n\n            /version\\/([\\w\\.]+)\\s.*mobile\\/\\w+\\s(safari)/i                      // Mobile Safari\n            ], [VERSION, [NAME, 'Mobile Safari']], [\n\n            /version\\/([\\w\\.]+)\\s.*(mobile\\s?safari|safari)/i                   // Safari & Safari Mobile\n            ], [VERSION, NAME], [\n\n            /webkit.+?(gsa)\\/([\\w\\.]+)\\s.*(mobile\\s?safari|safari)(\\/[\\w\\.]+)/i // Google Search Appliance on iOS\n            ], [[NAME, 'GSA'], VERSION], [\n\n            /webkit.+?(mobile\\s?safari|safari)(\\/[\\w\\.]+)/i                     // Safari < 3.0\n            ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [\n\n            /(webkit|khtml)\\/([\\w\\.]+)/i\n            ], [NAME, VERSION], [\n\n            // Gecko based\n            /(navigator|netscape)\\/([\\w\\.-]+)/i                                 // Netscape\n            ], [[NAME, 'Netscape'], VERSION], [\n            /(swiftfox)/i,                                                      // Swiftfox\n            /(icedragon|iceweasel|camino|chimera|fennec|maemo\\sbrowser|minimo|conkeror)[\\/\\s]?([\\w\\.\\+]+)/i,\n                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror\n            /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([\\w\\.-]+)$/i,\n\n                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix\n            /(firefox)\\/([\\w\\.]+)\\s[\\w\\s\\-]+\\/[\\w\\.]+$/i,                       // Other Firefox-based\n            /(mozilla)\\/([\\w\\.]+)\\s.+rv\\:.+gecko\\/\\d+/i,                        // Mozilla\n\n            // Other\n            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\\/\\s]?([\\w\\.]+)/i,\n                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir\n            /(links)\\s\\(([\\w\\.]+)/i,                                            // Links\n            /(gobrowser)\\/?([\\w\\.]*)/i,                                         // GoBrowser\n            /(ice\\s?browser)\\/v?([\\w\\._]+)/i,                                   // ICE Browser\n            /(mosaic)[\\/\\s]([\\w\\.]+)/i                                          // Mosaic\n            ], [NAME, VERSION]\n        ],\n\n        cpu : [[\n\n            /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\\)]/i                     // AMD64\n            ], [[ARCHITECTURE, 'amd64']], [\n\n            /(ia32(?=;))/i                                                      // IA32 (quicktime)\n            ], [[ARCHITECTURE, util.lowerize]], [\n\n            /((?:i[346]|x)86)[;\\)]/i                                            // IA32\n            ], [[ARCHITECTURE, 'ia32']], [\n\n            // PocketPC mistakenly identified as PowerPC\n            /windows\\s(ce|mobile);\\sppc;/i\n            ], [[ARCHITECTURE, 'arm']], [\n\n            /((?:ppc|powerpc)(?:64)?)(?:\\smac|;|\\))/i                           // PowerPC\n            ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [\n\n            /(sun4\\w)[;\\)]/i                                                    // SPARC\n            ], [[ARCHITECTURE, 'sparc']], [\n\n            /((?:avr32|ia64(?=;))|68k(?=\\))|arm(?:64|(?=v\\d+[;l]))|(?=atmel\\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i\n                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC\n            ], [[ARCHITECTURE, util.lowerize]]\n        ],\n\n        device : [[\n\n            /\\((ipad|playbook);[\\w\\s\\),;-]+(rim|apple)/i                        // iPad/PlayBook\n            ], [MODEL, VENDOR, [TYPE, TABLET]], [\n\n            /applecoremedia\\/[\\w\\.]+ \\((ipad)/                                  // iPad\n            ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [\n\n            /(apple\\s{0,1}tv)/i                                                 // Apple TV\n            ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple'], [TYPE, SMARTTV]], [\n\n            /(archos)\\s(gamepad2?)/i,                                           // Archos\n            /(hp).+(touchpad)/i,                                                // HP TouchPad\n            /(hp).+(tablet)/i,                                                  // HP Tablet\n            /(kindle)\\/([\\w\\.]+)/i,                                             // Kindle\n            /\\s(nook)[\\w\\s]+build\\/(\\w+)/i,                                     // Nook\n            /(dell)\\s(strea[kpr\\s\\d]*[\\dko])/i                                  // Dell Streak\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n            /(kf[A-z]+)(\\sbuild\\/|\\)).+silk\\//i                                 // Kindle Fire HD\n            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [\n            /(sd|kf)[0349hijorstuw]+(\\sbuild\\/|\\)).+silk\\//i                    // Fire Phone\n            ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [\n            /android.+aft([\\w])(\\sbuild\\/|\\))/i                                 // Fire TV\n            ], [MODEL, [VENDOR, 'Amazon'], [TYPE, SMARTTV]], [\n\n            /\\((ip[honed|\\s\\w*]+);.+(apple)/i                                   // iPod/iPhone\n            ], [MODEL, VENDOR, [TYPE, MOBILE]], [\n            /\\((ip[honed|\\s\\w*]+);/i                                            // iPod/iPhone\n            ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [\n\n            /(blackberry)[\\s-]?(\\w+)/i,                                         // BlackBerry\n            /(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\\s_-]?([\\w-]*)/i,\n                                                                                // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron\n            /(hp)\\s([\\w\\s]+\\w)/i,                                               // HP iPAQ\n            /(asus)-?(\\w+)/i                                                    // Asus\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n            /\\(bb10;\\s(\\w+)/i                                                   // BlackBerry 10\n            ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [\n                                                                                // Asus Tablets\n            /android.+(transfo[prime\\s]{4,10}\\s\\w+|eeepc|slider\\s\\w+|nexus 7|padfone|p00c)/i\n            ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [\n\n            /(sony)\\s(tablet\\s[ps])\\sbuild\\//i,                                  // Sony\n            /(sony)?(?:sgp.+)\\sbuild\\//i\n            ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [\n            /android.+\\s([c-g]\\d{4}|so[-l]\\w+)(?=\\sbuild\\/|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i\n            ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [\n\n            /\\s(ouya)\\s/i,                                                      // Ouya\n            /(nintendo)\\s([wids3u]+)/i                                          // Nintendo\n            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [\n\n            /android.+;\\s(shield)\\sbuild/i                                      // Nvidia\n            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [\n\n            /(playstation\\s[34portablevi]+)/i                                   // Playstation\n            ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [\n\n            /(sprint\\s(\\w+))/i                                                  // Sprint Phones\n            ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [\n\n            /(htc)[;_\\s-]{1,2}([\\w\\s]+(?=\\)|\\sbuild)|\\w+)/i,                    // HTC\n            /(zte)-(\\w*)/i,                                                     // ZTE\n            /(alcatel|geeksphone|nexian|panasonic|(?=;\\s)sony)[_\\s-]?([\\w-]*)/i\n                                                                                // Alcatel/GeeksPhone/Nexian/Panasonic/Sony\n            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [\n\n            /(nexus\\s9)/i                                                       // HTC Nexus 9\n            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [\n\n            /d\\/huawei([\\w\\s-]+)[;\\)]/i,                                        // Huawei\n            /android.+\\s(nexus\\s6p|vog-[at]?l\\d\\d|ane-[at]?l[x\\d]\\d|eml-a?l\\d\\da?|lya-[at]?l\\d[\\dc]|clt-a?l\\d\\di?)/i\n\n            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [\n\n            /android.+(bah2?-a?[lw]\\d{2})/i                                     // Huawei MediaPad\n            ], [MODEL, [VENDOR, 'Huawei'], [TYPE, TABLET]], [\n\n            /(microsoft);\\s(lumia[\\s\\w]+)/i                                     // Microsoft Lumia\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n            /[\\s\\(;](xbox(?:\\sone)?)[\\s\\);]/i                                   // Microsoft Xbox\n            ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [\n            /(kin\\.[onetw]{3})/i                                                // Microsoft Kin\n            ], [[MODEL, /\\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [\n\n                                                                                // Motorola\n            /\\s(milestone|droid(?:[2-4x]|\\s(?:bionic|x2|pro|razr))?:?(\\s4g)?)[\\w\\s]+build\\//i,\n            /mot[\\s-]?(\\w*)/i,\n            /(XT\\d{3,4}) build\\//i,\n            /(nexus\\s6)/i\n            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [\n            /android.+\\s(mz60\\d|xoom[\\s2]{0,2})\\sbuild\\//i\n            ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [\n\n            /hbbtv\\/\\d+\\.\\d+\\.\\d+\\s+\\([\\w\\s]*;\\s*(\\w[^;]*);([^;]*)/i            // HbbTV devices\n            ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [\n\n            /hbbtv.+maple;(\\d+)/i\n            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [\n\n            /\\(dtv[\\);].+(aquos)/i                                              // Sharp\n            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [\n\n            /android.+((sch-i[89]0\\d|shw-m380s|SM-P605|SM-P610|SM-P587|gt-p\\d{4}|gt-n\\d+|sgh-t8[56]9|nexus 10))/i,\n            /((SM-T\\w+))/i\n            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung\n            /smart-tv.+(samsung)/i\n            ], [VENDOR, [TYPE, SMARTTV], MODEL], [\n            /((s[cgp]h-\\w+|gt-\\w+|galaxy\\snexus|sm-\\w[\\w\\d]+))/i,\n            /(sam[sung]*)[\\s-]*(\\w+-?[\\w-]*)/i,\n            /sec-((sgh\\w+))/i\n            ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [\n\n            /sie-(\\w*)/i                                                        // Siemens\n            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [\n\n            /(maemo|nokia).*(n900|lumia\\s\\d+)/i,                                // Nokia\n            /(nokia)[\\s_-]?([\\w-]*)/i\n            ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [\n\n            /android[x\\d\\.\\s;]+\\s([ab][1-7]\\-?[0178a]\\d\\d?)/i                   // Acer\n            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [\n\n            /android.+([vl]k\\-?\\d{3})\\s+build/i                                 // LG Tablet\n            ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [\n            /android\\s3\\.[\\s\\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet\n            ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [\n            /linux;\\snetcast.+smarttv/i,                                        // LG SmartTV\n            /lg\\snetcast\\.tv-201\\d/i\n            ], [[VENDOR, 'LG'], MODEL, [TYPE, SMARTTV]], [\n            /(nexus\\s[45])/i,                                                   // LG\n            /lg[e;\\s\\/-]+(\\w*)/i,\n            /android.+lg(\\-?[\\d\\w]+)\\s+build/i\n            ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [\n\n            /(lenovo)\\s?(s(?:5000|6000)(?:[\\w-]+)|tab(?:[\\s\\w]+))/i             // Lenovo tablets\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n            /android.+(ideatab[a-z0-9\\-\\s]+)/i                                  // Lenovo\n            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [\n            /(lenovo)[_\\s-]?([\\w-]+)/i\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n            /linux;.+((jolla));/i                                               // Jolla\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n            /((pebble))app\\/[\\d\\.]+\\s/i                                         // Pebble\n            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [\n\n            /android.+;\\s(oppo)\\s?([\\w\\s]+)\\sbuild/i                            // OPPO\n            ], [VENDOR, MODEL, [TYPE, MOBILE]], [\n\n            /crkey/i                                                            // Google Chromecast\n            ], [[MODEL, 'Chromecast'], [VENDOR, 'Google'], [TYPE, SMARTTV]], [\n\n            /android.+;\\s(glass)\\s\\d/i                                          // Google Glass\n            ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [\n\n            /android.+;\\s(pixel c)[\\s)]/i                                       // Google Pixel C\n            ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [\n\n            /android.+;\\s(pixel( [2-9]a?)?( xl)?)[\\s)]/i                        // Google Pixel\n            ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [\n\n            /android.+;\\s(\\w+)\\s+build\\/hm\\1/i,                                 // Xiaomi Hongmi 'numeric' models\n            /android.+(hm[\\s\\-_]?note?[\\s_]?(?:\\d\\w)?)\\sbuild/i,                // Xiaomi Hongmi\n            /android.+(redmi[\\s\\-_]?(?:note|k)?(?:[\\s_]?[\\w\\s]+))(?:\\sbuild|\\))/i,      \n                                                                                // Xiaomi Redmi\n            /android.+(mi[\\s\\-_]?(?:a\\d|one|one[\\s_]plus|note lte)?[\\s_]?(?:\\d?\\w?)[\\s_]?(?:plus)?)\\sbuild/i    \n                                                                                // Xiaomi Mi\n            ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [\n            /android.+(mi[\\s\\-_]?(?:pad)(?:[\\s_]?[\\w\\s]+))(?:\\sbuild|\\))/i     // Mi Pad tablets\n            ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [\n            /android.+;\\s(m[1-5]\\snote)\\sbuild/i                                // Meizu\n            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [\n            /(mz)-([\\w-]{2,})/i\n            ], [[VENDOR, 'Meizu'], MODEL, [TYPE, MOBILE]], [\n\n            /android.+a000(1)\\s+build/i,                                        // OnePlus\n            /android.+oneplus\\s(a\\d{4})[\\s)]/i\n            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [\n\n            /android.+[;\\/]\\s*(RCT[\\d\\w]+)\\s+build/i                            // RCA Tablets\n            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [\n\n            /android.+[;\\/\\s](Venue[\\d\\s]{2,7})\\s+build/i                       // Dell Venue Tablets\n            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*(Q[T|M][\\d\\w]+)\\s+build/i                         // Verizon Tablet\n            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s+(Barnes[&\\s]+Noble\\s+|BN[RT])(\\S(?:.*\\S)?)\\s+build/i     // Barnes & Noble Tablet\n            ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s+(TM\\d{3}.*\\b)\\s+build/i                           // Barnes & Noble Tablet\n            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [\n\n            /android.+;\\s(k88)\\sbuild/i                                         // ZTE K Series Tablet\n            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*(gen\\d{3})\\s+build.*49h/i                         // Swiss GEN Mobile\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [\n\n            /android.+[;\\/]\\s*(zur\\d{3})\\s+build/i                              // Swiss ZUR Tablet\n            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*((Zeki)?TB.*\\b)\\s+build/i                         // Zeki Tablets\n            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [\n\n            /(android).+[;\\/]\\s+([YR]\\d{2})\\s+build/i,\n            /android.+[;\\/]\\s+(Dragon[\\-\\s]+Touch\\s+|DT)(\\w{5})\\sbuild/i        // Dragon Touch Tablet\n            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*(NS-?\\w{0,9})\\sbuild/i                            // Insignia Tablets\n            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*((NX|Next)-?\\w{0,9})\\s+build/i                    // NextBook Tablets\n            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*(Xtreme\\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\\s+build/i\n            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones\n\n            /android.+[;\\/]\\s*(LVTEL\\-)?(V1[12])\\s+build/i                     // LvTel Phones\n            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [\n\n            /android.+;\\s(PH-1)\\s/i\n            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [                // Essential PH-1\n\n            /android.+[;\\/]\\s*(V(100MD|700NA|7011|917G).*\\b)\\s+build/i          // Envizen Tablets\n            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*(Le[\\s\\-]+Pan)[\\s\\-]+(\\w{1,9})\\s+build/i          // Le Pan Tablets\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*(Trio[\\s\\w\\-\\.]+)\\s+build/i                       // MachSpeed Tablets\n            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*(Trinity)[\\-\\s]*(T\\d{3})\\s+build/i                // Trinity Tablets\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n\n            /android.+[;\\/]\\s*TU_(1491)\\s+build/i                               // Rotor Tablets\n            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [\n\n            //android.+(KS(.+))\\s+build/i                                        // Amazon Kindle Tablets\n            //], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [\n\n            /android.+(Gigaset)[\\s\\-]+(Q\\w{1,9})\\s+build/i                      // Gigaset Tablets\n            ], [VENDOR, MODEL, [TYPE, TABLET]], [\n                                                                                // Android Phones from Unidentified Vendors\n            /android .+?; ([^;]+?)(?: build|\\) applewebkit).+? mobile safari/i\n            ], [MODEL, [TYPE, MOBILE]], [\n                                                                                // Android Tablets from Unidentified Vendors\n            /android .+?;\\s([^;]+?)(?: build|\\) applewebkit).+?(?! mobile) safari/i\n            ], [MODEL, [TYPE, TABLET]], [\n\n            /\\s(tablet|tab)[;\\/]/i,                                             // Unidentifiable Tablet\n            /\\s(mobile)(?:[;\\/]|\\ssafari)/i                                     // Unidentifiable Mobile\n            ], [[TYPE, util.lowerize], VENDOR, MODEL], [\n\n            /[\\s\\/\\(](smart-?tv)[;\\)]/i                                         // SmartTV\n            ], [[TYPE, SMARTTV]], [\n\n            /(android[\\w\\.\\s\\-]{0,9});.+build/i                                 // Generic Android Device\n            ], [MODEL, [VENDOR, 'Generic']], [\n\n            /(phone)/i\n            ], [[TYPE, MOBILE]]\n        ],\n\n        engine : [[\n\n            /windows.+\\sedge\\/([\\w\\.]+)/i                                       // EdgeHTML\n            ], [VERSION, [NAME, 'EdgeHTML']], [\n\n            /webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i                         // Blink\n            ], [VERSION, [NAME, 'Blink']], [\n\n            /(presto)\\/([\\w\\.]+)/i,                                             // Presto\n            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i,\n                                                                                // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna\n            /(khtml|tasman|links)[\\/\\s]\\(?([\\w\\.]+)/i,                          // KHTML/Tasman/Links\n            /(icab)[\\/\\s]([23]\\.[\\d\\.]+)/i                                      // iCab\n            ], [NAME, VERSION], [\n\n            /rv\\:([\\w\\.]{1,9}).+(gecko)/i                                       // Gecko\n            ], [VERSION, NAME]\n        ],\n\n        os : [[\n\n            // Xbox, consider this before other Windows-based devices\n            /(xbox);\\s+xbox\\s([^\\);]+)/i,                                       // Microsoft Xbox (360, One, X, S, Series X, Series S)\n\n            // Windows based\n            /microsoft\\s(windows)\\s(vista|xp)/i                                 // Windows (iTunes)\n            ], [NAME, VERSION], [\n            /(windows)\\snt\\s6\\.2;\\s(arm)/i,                                     // Windows RT\n            /(windows\\sphone(?:\\sos)*)[\\s\\/]?([\\d\\.\\s\\w]*)/i,                   // Windows Phone\n            /(windows\\smobile|windows)[\\s\\/]?([ntce\\d\\.\\s]+\\w)/i\n            ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [\n            /(win(?=3|9|n)|win\\s9x\\s)([nt\\d\\.]+)/i\n            ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [\n\n            // Mobile/Embedded OS\n            /\\((bb)(10);/i                                                      // BlackBerry 10\n            ], [[NAME, 'BlackBerry'], VERSION], [\n            /(blackberry)\\w*\\/?([\\w\\.]*)/i,                                     // Blackberry\n            /(tizen|kaios)[\\/\\s]([\\w\\.]+)/i,                                    // Tizen/KaiOS\n            /(android|webos|palm\\sos|qnx|bada|rim\\stablet\\sos|meego|sailfish|contiki)[\\/\\s-]?([\\w\\.]*)/i\n                                                                                // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki/Sailfish OS\n            ], [NAME, VERSION], [\n            /(symbian\\s?os|symbos|s60(?=;))[\\/\\s-]?([\\w\\.]*)/i                  // Symbian\n            ], [[NAME, 'Symbian'], VERSION], [\n            /\\((series40);/i                                                    // Series 40\n            ], [NAME], [\n            /mozilla.+\\(mobile;.+gecko.+firefox/i                               // Firefox OS\n            ], [[NAME, 'Firefox OS'], VERSION], [\n\n            // Google Chromecast\n            /crkey\\/([\\d\\.]+)/i                                                 // Google Chromecast\n            ], [VERSION, [NAME, 'Chromecast']], [\n\n            // Console\n            /(nintendo|playstation)\\s([wids34portablevu]+)/i,                   // Nintendo/Playstation\n\n            // GNU/Linux based\n            /(mint)[\\/\\s\\(]?(\\w*)/i,                                            // Mint\n            /(mageia|vectorlinux)[;\\s]/i,                                       // Mageia/VectorLinux\n            /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\\/\\s-]?(?!chrom)([\\w\\.-]*)/i,\n                                                                                // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware\n                                                                                // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus\n            /(hurd|linux)\\s?([\\w\\.]*)/i,                                        // Hurd/Linux\n            /(gnu)\\s?([\\w\\.]*)/i                                                // GNU\n            ], [NAME, VERSION], [\n\n            /(cros)\\s[\\w]+\\s([\\w\\.]+\\w)/i                                       // Chromium OS\n            ], [[NAME, 'Chromium OS'], VERSION],[\n\n            // Solaris\n            /(sunos)\\s?([\\w\\.\\d]*)/i                                            // Solaris\n            ], [[NAME, 'Solaris'], VERSION], [\n\n            // BSD based\n            /\\s([frentopc-]{0,4}bsd|dragonfly)\\s?([\\w\\.]*)/i                    // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly\n            ], [NAME, VERSION],[\n\n            /(haiku)\\s(\\w+)/i                                                   // Haiku\n            ], [NAME, VERSION],[\n\n            /cfnetwork\\/.+darwin/i,\n            /ip[honead]{2,4}(?:.*os\\s([\\w]+)\\slike\\smac|;\\sopera)/i             // iOS\n            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [\n\n            /(mac\\sos\\sx)\\s?([\\w\\s\\.]*)/i,\n            /(macintosh|mac(?=_powerpc)\\s)/i                                    // Mac OS\n            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [\n\n            // Other\n            /((?:open)?solaris)[\\/\\s-]?([\\w\\.]*)/i,                             // Solaris\n            /(aix)\\s((\\d)(?=\\.|\\)|\\s)[\\w\\.])*/i,                                // AIX\n            /(plan\\s9|minix|beos|os\\/2|amigaos|morphos|risc\\sos|openvms|fuchsia)/i,\n                                                                                // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS/Fuchsia\n            /(unix)\\s?([\\w\\.]*)/i                                               // UNIX\n            ], [NAME, VERSION]\n        ]\n    };\n\n\n    /////////////////\n    // Constructor\n    ////////////////\n    var UAParser = function (uastring, extensions) {\n\n        if (typeof uastring === 'object') {\n            extensions = uastring;\n            uastring = undefined;\n        }\n\n        if (!(this instanceof UAParser)) {\n            return new UAParser(uastring, extensions).getResult();\n        }\n\n        var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);\n        var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;\n\n        this.getBrowser = function () {\n            var browser = { name: undefined, version: undefined };\n            mapper.rgx.call(browser, ua, rgxmap.browser);\n            browser.major = util.major(browser.version); // deprecated\n            return browser;\n        };\n        this.getCPU = function () {\n            var cpu = { architecture: undefined };\n            mapper.rgx.call(cpu, ua, rgxmap.cpu);\n            return cpu;\n        };\n        this.getDevice = function () {\n            var device = { vendor: undefined, model: undefined, type: undefined };\n            mapper.rgx.call(device, ua, rgxmap.device);\n            return device;\n        };\n        this.getEngine = function () {\n            var engine = { name: undefined, version: undefined };\n            mapper.rgx.call(engine, ua, rgxmap.engine);\n            return engine;\n        };\n        this.getOS = function () {\n            var os = { name: undefined, version: undefined };\n            mapper.rgx.call(os, ua, rgxmap.os);\n            return os;\n        };\n        this.getResult = function () {\n            return {\n                ua      : this.getUA(),\n                browser : this.getBrowser(),\n                engine  : this.getEngine(),\n                os      : this.getOS(),\n                device  : this.getDevice(),\n                cpu     : this.getCPU()\n            };\n        };\n        this.getUA = function () {\n            return ua;\n        };\n        this.setUA = function (uastring) {\n            ua = uastring;\n            return this;\n        };\n        return this;\n    };\n\n    UAParser.VERSION = LIBVERSION;\n    UAParser.BROWSER = {\n        NAME    : NAME,\n        MAJOR   : MAJOR, // deprecated\n        VERSION : VERSION\n    };\n    UAParser.CPU = {\n        ARCHITECTURE : ARCHITECTURE\n    };\n    UAParser.DEVICE = {\n        MODEL   : MODEL,\n        VENDOR  : VENDOR,\n        TYPE    : TYPE,\n        CONSOLE : CONSOLE,\n        MOBILE  : MOBILE,\n        SMARTTV : SMARTTV,\n        TABLET  : TABLET,\n        WEARABLE: WEARABLE,\n        EMBEDDED: EMBEDDED\n    };\n    UAParser.ENGINE = {\n        NAME    : NAME,\n        VERSION : VERSION\n    };\n    UAParser.OS = {\n        NAME    : NAME,\n        VERSION : VERSION\n    };\n\n    ///////////\n    // Export\n    //////////\n\n\n    // check js environment\n    if (typeof(exports) !== UNDEF_TYPE) {\n        // nodejs env\n        if (typeof module !== UNDEF_TYPE && module.exports) {\n            exports = module.exports = UAParser;\n        }\n        exports.UAParser = UAParser;\n    } else {\n        // requirejs env (optional)\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n                return UAParser;\n            }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else {}\n    }\n\n    // jQuery/Zepto specific (optional)\n    // Note:\n    //   In AMD env the global scope should be kept clean, but jQuery is an exception.\n    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,\n    //   and we should catch that.\n    var $ = window && (window.jQuery || window.Zepto);\n    if ($ && !$.ua) {\n        var parser = new UAParser();\n        $.ua = parser.getResult();\n        $.ua.get = function () {\n            return parser.getUA();\n        };\n        $.ua.set = function (uastring) {\n            parser.setUA(uastring);\n            var result = parser.getResult();\n            for (var prop in result) {\n                $.ua[prop] = result[prop];\n            }\n        };\n    }\n\n})(typeof window === 'object' ? window : this);\n\n\n//# sourceURL=webpack://Sonorous/../node_modules/ua-parser-js/src/ua-parser.js?");

/***/ }),

/***/ "./AudioContextManager/AudioContextManager.js":
/*!****************************************************!*\
  !*** ./AudioContextManager/AudioContextManager.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AudioContextManager; });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"../node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/environment */ \"./utils/environment.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n/**\n * The AudioContextManager handles creating and unlocking the AudioContext.\n * This module exposes the AudioContext and will notify users when it is\n * unlocked. This module is also a singleton, so you will only have 1 AudioContext\n * shared throughout.\n *\n * @export\n * @class AudioContextManager\n */\n\nvar AudioContext = window.AudioContext || window.webkitAudioContext; // eslint-disable-line no-shadow\n\nvar AudioContextManager = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of AudioContextManager. Will add event listeners on the document\n   * for user interaction (which will unlock the audio context). These event listeners will\n   * be removed once user interaction has happened.\n   *\n   * @memberof AudioContextManager\n   */\n  function AudioContextManager() {\n    _classCallCheck(this, AudioContextManager);\n\n    this._eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_0___default.a();\n    this._iOSContextReInitAttempts = 0;\n    this._maxIOSContextReInitAttempts = 5;\n    this.createAudioContext();\n    document.addEventListener('visibilitychange', this.onDocumentVisibilityChange.bind(this)); // If we were able to successfully create an AudioContext, then proceed with attempting to unlock it\n\n    if (this._context) {\n      this._isUnlocked = false; // Add listeners for unlocking web audio playback\n\n      document.addEventListener('touchend', this.unlockAudioContext.bind(this), true);\n      document.addEventListener('click', this.unlockAudioContext.bind(this), true);\n      document.addEventListener('keydown', this.unlockAudioContext.bind(this), true); // Let's try unlocking without user gesture\n\n      this.unlockAudioContext();\n    }\n  }\n\n  _createClass(AudioContextManager, [{\n    key: \"onDocumentVisibilityChange\",\n    value: function onDocumentVisibilityChange() {\n      var _this = this;\n\n      if (document.visibilityState !== 'visible') {\n        return;\n      } // This is necessary to fix a zombie audiocontext on iOS13\n\n\n      if (this._context && typeof this._context.resume === 'function' && typeof this._context.suspend === 'function' && this._context.state === 'running') {\n        var currentTime = this._context.currentTime;\n        setTimeout(function () {\n          if (currentTime === _this._context.currentTime) {\n            console.warn('Detected zombie AudioContext, explicitly suspending and resuming.'); // eslint-disable-line no-console\n\n            _this._context.suspend().then(function () {\n              return _this._context.resume();\n            });\n          }\n        }, 0);\n      }\n    }\n    /**\n     * Will close the existing context if one exists, and will create a new context.\n     * If WebAudio is not supported, then this will throw an error and return\n     *\n     * @returns A promise if the AudioContext was successfully created, nothing otherwise\n     * @memberof AudioContextManager\n     */\n\n  }, {\n    key: \"createAudioContext\",\n    value: function createAudioContext() {\n      // Close current _context if exists\n      if (this._context && this._context.state !== 'closed') {\n        this._context.close();\n      } // Create audio _context\n\n\n      this._isSupported = true;\n      this._context = new AudioContext();\n\n      if (!this._context) {\n        // Ios has a weird issue where sometimes you initialize the context and its null. Attempt to reinit here.\n        if (_utils_environment__WEBPACK_IMPORTED_MODULE_1__[\"default\"].os === 'ios') {\n          // eslint-disable-line no-magic-numbers\n          if (this._iOSContextReInitAttempts < this._maxIOSContextReInitAttempts) {\n            // eslint-disable-next-line max-len\n            console.warn('[createAudioContext] Re-initializing audio context instance, identified null audio context'); // eslint-disable-line no-console\n\n            this._iOSContextReInitAttempts++;\n            this.createAudioContext();\n            return;\n          } // eslint-disable-next-line max-len\n\n\n          console.warn('[createAudioContext] Exhausted maximum iOS re-init attempts.'); // eslint-disable-line no-console\n        } else {\n          this._isSupported = false;\n          console.error('[initAudioContext] Current browser does not support the WebAudio API.');\n          return;\n        }\n      } // For FF, we call resume() first and then suspend() (FF does not seem to suspend() immediately after AudioContext creation).\n\n\n      var retVal;\n\n      if (_utils_environment__WEBPACK_IMPORTED_MODULE_1__[\"default\"].browser === 'firefox') {\n        retVal = this._context.resume().then(this._context.suspend.bind(this._context));\n      } else {\n        retVal = this._context.suspend();\n      }\n\n      return retVal;\n    }\n  }, {\n    key: \"closeCurrentContext\",\n    value: function closeCurrentContext() {\n      if (this._context && this._context.state !== 'closed' && typeof this._context.close === 'function') {\n        try {\n          var retVal = this._context.close();\n\n          if (retVal && typeof retVal.then === 'function') {\n            retVal.then(function () {\n              console.log('Context successfully closed'); // eslint-disable-line no-console\n            }).catch(function (e) {\n              console.warn(\"Async error closing context: \".concat(e)); // eslint-disable-line no-console\n            });\n          }\n        } catch (e) {\n          console.warn(\"Error closing context: \".concat(e)); // eslint-disable-line no-console\n        }\n      }\n    }\n    /**\n     * Represents if WebAudio is supported. If we are unable to create an AudioContext, then\n     * this will be false, and this library will be unusable.\n     *\n     * @readonly\n     * @memberof AudioContextManager\n     */\n\n  }, {\n    key: \"unlockAudioContext\",\n\n    /**\n     * This will attempt to unlock the audio context by playing a buffer of silence. If the\n     * context has already been unlocked, this will do nothing and simply return.\n     *\n     * @returns\n     * @memberof AudioContextManager\n     */\n    value: function unlockAudioContext() {\n      // Do nothing if we're already unlocked\n      if (this.isUnlocked) {\n        return;\n      } // Create an empty buffer.\n\n\n      var buffer = this._context.createBuffer(1, 1, 22050); // eslint-disable-line no-magic-numbers\n\n\n      var source = this._context.createBufferSource();\n\n      source.buffer = buffer;\n      source.connect(this._context.destination); // Play the empty buffer\n\n      source.start(0);\n      console.log('[unlockAudioContext] Starting test to see if unlock was successful'); // eslint-disable-line no-console\n      // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n\n      this._context.resume().then(function () {\n        // Do nothing if we're already unlocked\n        if (this.isUnlocked) {\n          return;\n        }\n\n        console.log('[unlockAudioContext] Resolving unlockedDefer - unlock test was successful'); // eslint-disable-line no-console\n\n        console.log('[ctor] Removing document listeners'); // eslint-disable-line no-console\n\n        document.removeEventListener('touchend', this.unlockAudioContext, true);\n        document.removeEventListener('click', this.unlockAudioContext, true);\n        document.removeEventListener('keydown', this.unlockAudioContext, true);\n        this._isUnlocked = true;\n\n        this._eventEmitter.emit('audiounlocked');\n      }.bind(this));\n    }\n    /**\n     * Event emitter function that will let a module register a callback for a specified event issued from\n     * the AudioContextManager.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof AudioContextManager\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      this._eventEmitter.on(eventName, callback);\n    }\n    /**\n     * Event emitter function that will let a module remove a callback for a specified event issued from\n     * the AudioContextManager.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof AudioContextManager\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, callback) {\n      this._eventEmitter.off(eventName, callback);\n    }\n    /**\n     * Event emitter function that will let a module register a callback for a specified event\n     * from the AudioContextManager. The callback will only be called once, while the event may\n     * be emitted more than once.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof AudioContextManager\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(eventName, callback) {\n      this._eventEmitter.once(eventName, callback);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      window.removeEventListener('visibilitychange', this.onDocumentVisibilityChange);\n      this._eventEmitter = null;\n\n      if (this._context.state !== 'closed') {\n        this.closeCurrentContext();\n        this._context = null;\n      }\n    }\n  }, {\n    key: \"isSupported\",\n    get: function get() {\n      return this._isSupported;\n    }\n    /**\n     * Represents if the audio context has been unlocked yet. In most cases, the audio context\n     * will only be unlocked once there is a user interaction on the page\n     *\n     * @readonly\n     * @memberof AudioContextManager\n     */\n\n  }, {\n    key: \"isUnlocked\",\n    get: function get() {\n      return this._isUnlocked;\n    }\n    /**\n     * Returns the audiocontext. Connecting nodes to the context's destination will allow you\n     * to hear what's being played\n     *\n     * @readonly\n     * @memberof AudioContextManager\n     */\n\n  }, {\n    key: \"context\",\n    get: function get() {\n      return this._context;\n    }\n  }], [{\n    key: \"instance\",\n    get: function get() {\n      if (!this._instance) {\n        this._instance = new AudioContextManager();\n      }\n\n      return this._instance;\n    }\n  }]);\n\n  return AudioContextManager;\n}();\n\n\n\n//# sourceURL=webpack://Sonorous/./AudioContextManager/AudioContextManager.js?");

/***/ }),

/***/ "./Sonor/AudioSegment.js":
/*!*******************************!*\
  !*** ./Sonor/AudioSegment.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AudioContextManager_AudioContextManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AudioContextManager/AudioContextManager */ \"./AudioContextManager/AudioContextManager.js\");\n/* harmony import */ var _utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/copySetterGetterFromInstance */ \"./utils/copySetterGetterFromInstance.js\");\n/* harmony import */ var _utils_ActionQueue_ActionQueue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ActionQueue/ActionQueue */ \"./utils/ActionQueue/ActionQueue.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventemitter3 */ \"../node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _utils_environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/environment */ \"./utils/environment.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\n\n\nvar clampWithWarning = function clampWithWarning(min, max, value, warningMsg) {\n  var clampedValue = value;\n\n  if (value < min || value > max) {\n    clampedValue = Math.max(min, Math.min(max, value));\n\n    if (warningMsg) {\n      // eslint-disable-next-line no-console\n      console.warn(\"\".concat(warningMsg, \" Allowed Range: [\").concat(min, \", \").concat(max, \"] Changing to:\").concat(clampedValue));\n    }\n  }\n\n  return clampedValue;\n};\n/**\n * AudioSegment is a wrapper over the AudioBufferSourceNode. It will handle most of the functionality\n * of playing, pausing, volume, etc.\n *\n * @export\n * @class AudioSegment\n */\n\n\nvar AudioSegment = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of AudioSegment.\n   * @param {AudioContext} context - Required. The AudioContext is necessary to create source nodes, etc.\n   * @param {*} destNode - Required. The node that we will connect our gainnode to.\n   * @param {string} id - Optional. The id of the audio segment.\n   * @memberof AudioSegment\n   */\n  function AudioSegment(context, destNode, id) {\n    var _this = this;\n\n    _classCallCheck(this, AudioSegment);\n\n    this._context = context;\n    this._eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_3___default.a();\n    this._actionQueue = new _utils_ActionQueue_ActionQueue__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    this._destNode = destNode;\n\n    if (typeof id === 'string') {\n      this._id = id;\n    } else {\n      // eslint-disable-next-line no-magic-numbers\n      this._id = Math.random().toString(36).substr(2, 9); // eslint-disable-line no-magic-numbers\n    } // Initialize private properties\n\n\n    this._playbackRate = 1.0;\n    this._volume = 1.0;\n    this._muted = false;\n    this._isPaused = false;\n    this._looping = false;\n    this._start = 0.0;\n    this._duration = 0.0;\n    this._contextPlayStartTime = 0.0;\n    this._seekPosition = 0.0;\n    _AudioContextManager_AudioContextManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance.on('audiounlocked', function () {\n      _this.startEventQueueIfReady();\n    }); // Define the gain/source nodes\n\n    this.load();\n    this._sourceNode = null;\n    this._buffer = null; // Generate our public functionality object (this.exports)\n\n    this.exportPublicAPI();\n    return this.exports;\n  } ///////////////////////\n  // PROPERTIES\n  ///////////////////////\n\n  /**\n   * Controls the volume of the sound\n   * @name AudioSegment#volume\n   * @type Number\n   * @default 1.0\n   * @memberof AudioSegment\n   */\n\n\n  _createClass(AudioSegment, [{\n    key: \"play\",\n    ///////////////////////\n    // PUBLIC FUNCTIONALITY\n    ///////////////////////\n\n    /**\n     * Play() handles creating a source from a buffer, resuming the context\n     * if necessary, and then starting the source. A new source buffer will\n     * be created every time play is called. The source buffer will only be\n     * created through play (i.e. no other operations will refresh the buffer).\n     * This function will also set isPlaying to true.\n     *\n     * @memberof AudioSegment\n     */\n    value: function play() {\n      // Note that all we do is push an event to the queue. Please see this._play() for the actual implementation.\n      // If the queue has been started, we will play immediately. If not, it will play as soon as the queue has started.\n      this._actionQueue.push({\n        name: 'play',\n        onExecute: this._play.bind(this)\n      });\n    }\n    /**\n     * Will \"pause\" the sound by stopping the source buffer and storing the time to re-start at.\n     * It will set isPlaying to false.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      // Note that all we do is push the event to the queue. Please see this._pause() for the actual implementation.\n      // If the queue has been started, we will pause immediately. If not, it will pause as soon as the queue has started.\n      this._actionQueue.push({\n        name: 'pause',\n        onExecute: this._pause.bind(this)\n      });\n    }\n    /**\n     * Stop() handles stopping the current source buffer, if one exists.\n     * It will set isPlaying to false.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // Note that all we do is push the event to the queue. Please see this._stop() for the actual implementation.\n      // If the queue has been started, we will stop immediately. If not, it will stop as soon as the queue has started.\n      this._actionQueue.push({\n        name: 'stop',\n        onExecute: this._stop.bind(this)\n      });\n    }\n    /**\n     * If we're currently playing, then this will stop the current buffer node, set the seek position, and resume play.\n     * If we aren't playing, then this will set the seek position and when play is started, it will play from this point.\n     *\n     * @param {Number} newSeekPosition - the position to seek to. It will be bounded by the start/duration of the audio.\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"seek\",\n    value: function seek(newSeekPosition) {\n      // eslint-disable-line no-unused-vars\n      // Note that all we do is push the event to the queue. Please see this._seek() for the actual implementation.\n      // If the queue has been started, we will seek immediately. If not, it will seek as soon as the queue has started.\n      this._actionQueue.push({\n        name: 'seek',\n        onExecute: this._seek.bind(this),\n        args: arguments\n      });\n    }\n    /**\n     * Fades from one volume to another using the gain node's linear fade functionality.\n     * Allows scheduling a fade to appear later in the audio's sound. startTime is currently\n     * in terms of audio start, not context start. If we're not playing, then the fade will\n     * not register.\n     *\n     * @param {Number} stopVolume\n     * @param {Number} fadeDuration\n     * @param {Number} startTime\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"fade\",\n    value: function fade(stopVolume, fadeDuration, startTime) {\n      // Validate inputs\n      if (typeof stopVolume !== 'number' || typeof fadeDuration !== 'number' || startTime && typeof startTime !== 'number') {\n        throw new TypeError('Invalid type given to fade- expected numbers for all parameters');\n      } // Note that all we do is push the event to the queue. Please see this._fade() for the actual implementation.\n      // If the queue has been started, we will fade immediately. If not, it will fade as soon as the queue has started.\n\n\n      this._actionQueue.push({\n        name: 'fade',\n        onExecute: this._fade.bind(this),\n        args: arguments\n      });\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      if (!this._gainNode) {\n        this._gainNode = this._context.createGain();\n\n        this._gainNode.connect(this._destNode);\n\n        this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n      }\n    }\n    /**\n     * Stops and disposes of the current buffer source node. Disconnects from the\n     * audio graph. Clears out the stored buffer.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      this._actionQueue.stop();\n\n      this.disposeBufferSourceNode();\n      this._buffer = null;\n\n      if (this._gainNode) {\n        this._gainNode.disconnect();\n      }\n\n      this._gainNode = null;\n    }\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      this._eventEmitter.on(eventName, callback);\n    }\n  }, {\n    key: \"off\",\n    value: function off(eventName, callback) {\n      this._eventEmitter.off(eventName, callback);\n    }\n  }, {\n    key: \"once\",\n    value: function once(eventName, callback) {\n      this._eventEmitter.once(eventName, callback);\n    } ///////////////////////\n    // PRIVATE FUNCTIONALITY\n    ///////////////////////\n\n    /**\n     * Private function. Will emit an event and pass the audio segment instance\n     * as one of the arguments, along with any other args specified.\n     *\n     * @param {*} eventName\n     * @param {*} args\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"trigger\",\n    value: function trigger(eventName) {\n      var _this$_eventEmitter;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (_this$_eventEmitter = this._eventEmitter).emit.apply(_this$_eventEmitter, [eventName, this.exports].concat(args));\n    }\n    /**\n     * Private function. Will generate the exports object, which includes all the functions external users\n     * can call, and will copy all public properties from the instance to this object.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"exportPublicAPI\",\n    value: function exportPublicAPI() {\n      this.exports = {\n        play: this.play.bind(this),\n        pause: this.pause.bind(this),\n        stop: this.stop.bind(this),\n        seek: this.seek.bind(this),\n        fade: this.fade.bind(this),\n        load: this.load.bind(this),\n        unload: this.unload.bind(this),\n        getPlayheadPosition: this.getPlayheadPosition.bind(this),\n        on: this.on.bind(this),\n        once: this.once.bind(this),\n        off: this.off.bind(this)\n      };\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'volume');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'playbackRate');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'loop');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'muted');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'buffer');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'isPlaying', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'id', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'duration', true);\n    }\n    /**\n     * Private function. Currently, the queue can be started if the audio context is unlocked\n     * AND if the buffer has been loaded. This function checks if both those conditions have\n     * been met and will start the event queue if so.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"startEventQueueIfReady\",\n    value: function startEventQueueIfReady() {\n      if (_AudioContextManager_AudioContextManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance.isUnlocked && this.buffer) {\n        this._actionQueue.start();\n      }\n    }\n    /**\n     * Private function. Given some number, this will calculate what the looped position in the sonor would be.\n     * (Essentially calculate the remainder of a newPos%duration)\n     * @param {*} newPos\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"calculateLoopedPosition\",\n    value: function calculateLoopedPosition(newPos) {\n      if (this._duration) {\n        return newPos / this._duration % 1 * this._duration;\n      }\n\n      return newPos;\n    }\n    /**\n     * Private function.\n     * The actual implementation of play functionality. This will handle creating and starting\n     * the buffer source node and emitting the event.\n     *\n     * @returns\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"_play\",\n    value: function _play() {\n      // If we're already playing, don't do anything.\n      if (this._isPlaying) {\n        this.trigger('error', 'Already playing this sound. Please pause/stop or wait until it has ended.');\n        return;\n      }\n\n      this._sourceNode = this.createSourceFromBuffer(this.buffer);\n\n      if (this._context.state === 'suspended' || this._context.state === 'interrupted') {\n        this._context.resume().then(this.startBufferSourceNode.bind(this));\n      } else {\n        this.startBufferSourceNode();\n      }\n    }\n    /**\n     * Private function.\n     * The actual implementation of pause functionality. This will dispose of the source node,\n     * set the seekPosition and emit the pause event.\n     *\n     * @returns\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      if (!this._sourceNode) {\n        // Nothing to pause\n        return;\n      }\n\n      if (!this._isPlaying) {\n        // We're not playing, so don't pause\n        return;\n      }\n\n      this._seekPosition = this.getPlayheadPosition();\n      this.disposeBufferSourceNode();\n      this._isPlaying = false;\n      this._isPaused = true;\n      this.trigger('pause');\n    }\n    /**\n     * Private function.\n     * The actual stop functionality. This will dispose of the source node, and emit the stop event.\n     *\n     * @returns\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop() {\n      if (!this._isPlaying) {\n        console.warn(\"[AudioSegment] No playback to stop, as the segment is not currently playing. Resetting the segment.\"); // eslint-disable-line\n        // Don't trigger the stop notification, but reset the segment accordingly\n\n        this._seekPosition = this._start;\n        this.disposeBufferSourceNode();\n        this._isPaused = false;\n        return;\n      }\n\n      if (!this._sourceNode) {\n        console.warn(\"[AudioSegment] Cannot stop playback, as there is no source node\"); // eslint-disable-line\n\n        return; // Nothing to stop\n      }\n\n      this._seekPosition = this._start;\n      this.disposeBufferSourceNode();\n      this._isPlaying = false;\n      this._isPaused = false;\n      this.trigger('stop');\n    }\n    /**\n     * Private function.\n     * The actual seek functionality. This will set the seek position and if currently playing,\n     * continue playback at that point.\n     *\n     * @param {*} newSeekPosition\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"_seek\",\n    value: function _seek(newSeekPosition) {\n      if (typeof newSeekPosition !== 'number') {\n        throw new TypeError('Seek expected a number for newSeekPosition.');\n      }\n\n      var calculatedSeekPosition;\n\n      if (this._looping) {\n        calculatedSeekPosition = this.calculateLoopedPosition(newSeekPosition);\n      } else {\n        calculatedSeekPosition = clampWithWarning(this._start, this._duration, newSeekPosition, 'Seek Position was beyond the limits of the buffer start/end.');\n      }\n\n      if (this._isPlaying) {\n        this._stop();\n\n        this._seekPosition = calculatedSeekPosition;\n\n        this._play();\n      } else {\n        this._seekPosition = calculatedSeekPosition;\n      }\n\n      this.trigger('seeked', calculatedSeekPosition);\n    }\n    /**\n     * Private function.\n     * The actual fade functionality. This will handle setting the fade and emitting the event.\n     *\n     * @param {*} stopVolume\n     * @param {*} fadeDuration\n     * @param {*} startTime\n     * @returns\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"_fade\",\n    value: function _fade(stopVolume, fadeDuration, startTime) {\n      var _this2 = this;\n\n      // If we're muted or not playing, then don't do anything\n      if (this.muted || !this.isPlaying) {\n        console.warn('[AudioSegment] Attempting to fade a sonor that is muted or not playing'); // eslint-disable-line no-console\n\n        return;\n      }\n\n      var clampedEndVolume = this.clampVolume(stopVolume);\n      var finalDuration = fadeDuration;\n      var willSchedule = false;\n\n      if (startTime) {\n        var currentPlayheadPosition = this.getPlayheadPosition();\n\n        if (startTime <= currentPlayheadPosition) {\n          // The fade should have already started\n          // (Linearly) interpolate what the volume should be if it started right now\n          var timeElapsedSinceStart = currentPlayheadPosition - startTime;\n          var ratio = timeElapsedSinceStart / fadeDuration;\n          this.volume = this.volume * ratio;\n          finalDuration = fadeDuration - timeElapsedSinceStart;\n        } else {\n          willSchedule = true;\n          var timeoutDuration = startTime - currentPlayheadPosition;\n          setTimeout(function () {\n            return _this2.startFade(clampedEndVolume, fadeDuration);\n          }, timeoutDuration * 1000.0);\n        }\n      }\n\n      if (!willSchedule) {\n        this.startFade(clampedEndVolume, finalDuration);\n      }\n    }\n    /**\n     * Private function. This will set the current context play time, start the node, and set isplaying to true.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"startBufferSourceNode\",\n    value: function startBufferSourceNode() {\n      this._contextPlayStartTime = this._context.currentTime - this._seekPosition;\n\n      if (this._sourceNode) {\n        this._sourceNode.start(0, this._seekPosition);\n\n        this._isPlaying = true;\n        this._isPaused = false;\n        this.trigger('play');\n      } else {\n        console.warn('Unable to start playback. No source node created'); // eslint-disable-line no-console\n      }\n    }\n    /**\n     * Private function. This will stop, disconnect, and remove the source node, if one exists.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"disposeBufferSourceNode\",\n    value: function disposeBufferSourceNode() {\n      if (this._sourceNode) {\n        this._sourceNode.stop(0);\n\n        this._sourceNode.disconnect();\n\n        var isSafariOriOS = _utils_environment__WEBPACK_IMPORTED_MODULE_4__[\"default\"].os === 'ios' || _utils_environment__WEBPACK_IMPORTED_MODULE_4__[\"default\"].browser === 'safari'; // Safari iOS seems to leak AudioBuffer memory, even if we clear references.\n        // The only way to dispose of it seems to be to also assign a dummy buffer to AudioBufferSourceNode.\n\n        try {\n          if (isSafariOriOS) {\n            var dummyBuffer;\n\n            if (this._context) {\n              if (!this._context.__dummyBuffer) {\n                // eslint-disable-next-line no-magic-numbers\n                this.context.__dummyBuffer = this.context.createBuffer(1, 1, 22050);\n              }\n\n              dummyBuffer = this.context.__dummyBuffer;\n            }\n\n            if (dummyBuffer) {\n              this._sourceNode.buffer = dummyBuffer;\n            }\n          } else {\n            this._sourceNode.buffer = null;\n          }\n        } catch (e) {}\n\n        this._sourceNode.onended = null;\n        this._sourceNode = null;\n      }\n    }\n    /**\n     * Private function. onEnded will be called whenever the AudioSourceBufferNode's \"onEnded\" is triggered.\n     *\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"onEnded\",\n    value: function onEnded() {\n      if (!this._isPaused) {\n        this._seekPosition = this._start;\n      }\n\n      this._isPlaying = false;\n      this.disposeBufferSourceNode();\n      this.trigger('ended');\n    }\n    /**\n     * CreateSourceFromBuffer is a private function that will create the source node from the decoded buffer data.\n     * It will error out if there is no buffer or no context (necessary to create the source node). This function\n     * will be called whenever we need to play. We will also set values on the source node, like looping,\n     * playback rate, etc.\n     *\n     * @param {AudioBuffer} buffer - the buffer to store in the AudioBufferSourceNode\n     * @returns {AudioBufferSourceNode}\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"createSourceFromBuffer\",\n    value: function createSourceFromBuffer(buffer) {\n      if (!buffer) {\n        console.log('Did not receive a buffer'); // eslint-disable-line no-console\n\n        return;\n      }\n\n      if (!this._context) {\n        console.log('Do not have a context, cannot create an audio node'); // eslint-disable-line no-console\n\n        return;\n      }\n\n      var source = this._context.createBufferSource();\n\n      source.buffer = buffer;\n      source.loop = this._looping;\n      this._playbackRate = clampWithWarning(source.playbackRate.minValue, source.playbackRate._maxValue, this._playbackRate, 'Previously set playback rate is out of bounds.');\n      source.playbackRate.value = this._playbackRate;\n      source.onended = this.onEnded.bind(this);\n      source.connect(this._gainNode);\n      return source;\n    }\n    /**\n     * Private function. Returns how far into playback we are. This is relative to the\n     * duration of the buffer and will take into account looping.\n     * Ex. If we have played a 30s audio through once, and we are 10s into the second time\n     * playing it, we will return 10s.\n     * @returns {Number} how far into playback we are\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"getPlayheadPosition\",\n    value: function getPlayheadPosition() {\n      if (this._isPlaying) {\n        var timeElapsed = this._context.currentTime - this._contextPlayStartTime; // If we have looped already, then the time elapsed is going to be greater than the duration\n        // We want to figure out how far we are into the sound on its current iteration.\n        // The code below divides the timeElapsed by the duration and mods by 1 - to get only the decimal part.\n        // Then multiply that by the duration.\n\n        if (this._duration === 0) {\n          console.warn(\"[AudioSegment] A duration is not set for the current audio segment. Cannot calculate playback position.\"); // eslint-disable-line\n\n          return this._seekPosition;\n        }\n\n        return this.calculateLoopedPosition(timeElapsed);\n      }\n\n      return this._seekPosition;\n    }\n    /**\n     * Private function. This will kick off the fade immediately.\n     *\n     * @param {Number} endVolume\n     * @param {Number} duration\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"startFade\",\n    value: function startFade(endVolume, duration) {\n      var _this3 = this;\n\n      var currentTime = this._context.currentTime;\n      var endTime = currentTime + duration;\n\n      this._gainNode.gain.linearRampToValueAtTime(endVolume, endTime);\n\n      setTimeout(function () {\n        _this3.trigger('fadefinished');\n\n        _this3.volume = endVolume;\n      }, duration * 1000.0);\n    }\n    /**\n     * Private function. This is a helper function and will clamp the\n     * volume according to the gain node's min/max and send a warning\n     * to the console if it must be clamped.\n     *\n     * @param {Number} vol\n     * @returns {Number} clamped volume\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"clampVolume\",\n    value: function clampVolume(vol) {\n      var clampedVol = vol;\n\n      if (this._gainNode) {\n        var minPossibleVolume = this._gainNode.gain.minValue;\n        var maxPossibleVolume = this._gainNode.gain.maxValue;\n        clampedVol = clampWithWarning(minPossibleVolume, maxPossibleVolume, vol, 'Volume value is out of bounds.');\n      }\n\n      return clampedVol;\n    }\n  }, {\n    key: \"volume\",\n    get: function get() {\n      return this._volume;\n    },\n    set: function set(newVolumeValue) {\n      if (typeof newVolumeValue !== 'number') {\n        throw new TypeError('Invalid type given to volume setter - expected a number.');\n      }\n\n      newVolumeValue = this.clampVolume(newVolumeValue);\n      this._volume = newVolumeValue;\n      this.trigger('volumechanged', newVolumeValue); // If its not muted then set the volume\n\n      if (!this._muted && this._gainNode) {\n        this._gainNode.gain.setValueAtTime(newVolumeValue, this._context.currentTime);\n      }\n    }\n    /**\n     * Controls the playback rate of the sound\n     * @name AudioSegment#playbackRate\n     * @type Number\n     * @default 1.0\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(newPlaybackRateValue) {\n      if (typeof newPlaybackRateValue !== 'number') {\n        throw new TypeError('Invalid type given to playback rate setter - expected a number.');\n      }\n\n      this._playbackRate = newPlaybackRateValue;\n      this.trigger('playbackratechanged', newPlaybackRateValue); // If we have a source node, then set its playback rate\n\n      if (this._sourceNode) {\n        newPlaybackRateValue = clampWithWarning(this._sourceNode.playbackRate.minValue, this._sourceNode.playbackRate.maxValue, newPlaybackRateValue, 'Playback Rate value is out of bounds.');\n        this._sourceNode.playbackRate.value = newPlaybackRateValue;\n      }\n    }\n    /**\n     * Controls if the sound will loop indefinitely or not\n     * @name AudioSegment#loop\n     * @type Boolean\n     * @default false\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._looping;\n    },\n    set: function set(newIsLooping) {\n      this._looping = newIsLooping; // If we have a source node, then set its looping value\n\n      if (this._sourceNode) {\n        this._sourceNode.loop = newIsLooping;\n      }\n    }\n    /**\n     * Controls if the sound is muted or not\n     * @name AudioSegment#muted\n     * @type Boolean\n     * @default false\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"muted\",\n    get: function get() {\n      return this._muted;\n    },\n    set: function set(newMutedValue) {\n      if (typeof newMutedValue !== 'boolean') {\n        throw new TypeError('Invalid type given to muted setter - expected a boolean.');\n      }\n\n      this._muted = newMutedValue;\n      var volValue = newMutedValue ? 0.0 : this._volume;\n\n      if (this._gainNode) {\n        this._gainNode.gain.setValueAtTime(volValue, this._context.currentTime);\n\n        this.trigger('volumechanged', volValue);\n      }\n    }\n    /**\n     * Returns true if a sound is currently playing, false otherwise\n     * @name AudioSegment#isPlaying\n     * @type boolean\n     * @readonly\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"isPlaying\",\n    get: function get() {\n      // In the off chance that the context is suspended but we're still playing, immediately pause and return false.\n      if (this._context.state !== 'running' && this._isPlaying) {\n        this.pause();\n        return false;\n      }\n\n      return this._isPlaying;\n    }\n    /**\n     * The buffer to create the source node with. If this is not set, this class will not be functional.\n     * @name AudioSegment#buffer\n     * @type {AudioBuffer}\n     * @memberof AudioSegment\n     */\n\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this._buffer;\n    },\n    set: function set(newDecodedBuffer) {\n      this._buffer = newDecodedBuffer;\n      this._duration = newDecodedBuffer ? newDecodedBuffer.duration : 0;\n      this.startEventQueueIfReady();\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      return this._duration;\n    }\n  }]);\n\n  return AudioSegment;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioSegment);\n\n//# sourceURL=webpack://Sonorous/./Sonor/AudioSegment.js?");

/***/ }),

/***/ "./Sonor/AudioSegmentPool.js":
/*!***********************************!*\
  !*** ./Sonor/AudioSegmentPool.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AudioSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AudioSegment */ \"./Sonor/AudioSegment.js\");\n/* harmony import */ var _utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/copySetterGetterFromInstance */ \"./utils/copySetterGetterFromInstance.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\nfunction generateRandomString() {\n  return Math.random().toString(36); // eslint-disable-line no-magic-numbers\n}\n/**\n * AudioSegmentPool creates a fixed number of AudioSegments. Other classes are able to access AudioSegments from this pool\n * and use them accordingly. Once the class is done, it should return the AudioSegment to the pool. It is not possible to\n * return more segments than the maximum capacity of the pool. (i.e. if the pool size is 5, you cannot return 6 segments to the pool)\n *\n * @export\n * @class AudioSegmentPool\n */\n\n\nvar AudioSegmentPool = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of AudioSegmentPool.\n   * @param {AudioContext} context - Required. The AudioContext to connect the audiosegments to.\n   * @param {*} destNode - Required. The destination node to connect the audiosegments to.\n   * @param {number} [maxSize = 1] - Optional. The maxmimum capacity of the pool, must be a positive integer greater than 0. Defaults to 1.\n   * @memberof AudioSegmentPool\n   */\n  function AudioSegmentPool(context, destNode, maxSize) {\n    _classCallCheck(this, AudioSegmentPool);\n\n    if (!context) {\n      throw new Error(\"Can't construct AudioSegmentPool - missing \\\"context\\\" value\");\n    }\n\n    if (!destNode) {\n      throw new Error(\"Can't construct AudioSegmentPool - missing \\\"destNode\\\" value\");\n    }\n\n    if (maxSize) {\n      if (typeof maxSize !== 'number') {\n        throw new TypeError(\"Expected maxSize to be a number. Received \".concat(_typeof(maxSize)));\n      }\n\n      if (maxSize <= 0) {\n        throw new TypeError(\"Expected maxSize to be a number greater than 0. Received \".concat(maxSize));\n      }\n    } // Store the max size of the pool\n\n\n    this._maxSize = maxSize || 1;\n    this._context = context;\n    this._destNode = destNode; // Create the list of AudioSegments\n\n    this._availableSegments = [];\n    this._inUseSegments = [];\n\n    for (var i = 0; i < this._maxSize; i++) {\n      var audioSegment = new _AudioSegment__WEBPACK_IMPORTED_MODULE_0__[\"default\"](context, destNode, generateRandomString());\n      audioSegment.unload(); // Keep each audio segment unloaded to start\n\n      this._availableSegments.push(audioSegment);\n    } // Generate our public functionality object (this.exports)\n\n\n    this.exportPublicAPI();\n    return this.exports;\n  } ///////////////////////\n  // PROPERTIES\n  ///////////////////////\n\n  /**\n   * The maximum size of the pool.\n   * @name AudioSegmentPool#maxSize\n   * @type Number\n   * @readonly\n   * @memberof AudioSegmentPool\n   */\n\n\n  _createClass(AudioSegmentPool, [{\n    key: \"canRetrieve\",\n    ///////////////////////\n    // PUBLIC FUNCTIONALITY\n    ///////////////////////\n\n    /**\n     * Returns true/false based on if there are available segments within the pool.\n     *\n     * @returns true if there are more inactive segments within the pool, false otherwise\n     * @memberof AudioSegmentPool\n     */\n    value: function canRetrieve() {\n      return this._availableSegments.length > 0;\n    }\n    /**\n     * Returns an AudioSegment (and removes it from the pool) if there is one available.\n     *\n     * @returns AudioSegment if it can, undefined otherwise\n     * @memberof AudioSegmentPool\n     */\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve() {\n      if (this.canRetrieve()) {\n        var audioSegment = this._availableSegments.shift();\n\n        audioSegment.load();\n\n        this._inUseSegments.push(audioSegment);\n\n        return audioSegment;\n      }\n\n      console.warn('All segments are currently being used. Returning undefined.'); // eslint-disable-line no-console\n\n      return undefined;\n    }\n    /**\n     * Adds a segment back to the pool. If the pool has already hit max capacity, then this will do nothing.\n     *\n     * @param {AudioSegment} audioSegment\n     * @memberof AudioSegmentPool\n     */\n\n  }, {\n    key: \"returnSegment\",\n    value: function returnSegment(audioSegment) {\n      var index = this._inUseSegments.indexOf(audioSegment);\n\n      if (index >= 0) {\n        this._inUseSegments.splice(index, 1);\n\n        audioSegment.unload();\n\n        if (this._availableSegments.length < this._maxSize) {\n          this._availableSegments.push(audioSegment);\n        } else {\n          console.warn('Unable to add audio segment to pool. Reached max capacity.'); // eslint-disable-line no-console\n        }\n      } else {\n        console.warn('Unable to add audio segment to pool. Segment was not found in pool to begin with.'); // eslint-disable-line no-console\n      }\n    } ///////////////////////\n    // PRIVATE FUNCTIONALITY\n    ///////////////////////\n\n    /**\n     * Private function. Will generate the exports object, which includes all the functions external users\n     * can call, and will copy all public properties from the instance to this object.\n     *\n     * @memberof AudioSegmentPool\n     */\n\n  }, {\n    key: \"exportPublicAPI\",\n    value: function exportPublicAPI() {\n      this.exports = {\n        retrieve: this.retrieve.bind(this),\n        canRetrieve: this.canRetrieve.bind(this),\n        returnSegment: this.returnSegment.bind(this)\n      };\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'maxSize');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, this.exports, 'availableSegmentCount', true);\n    }\n  }, {\n    key: \"maxSize\",\n    get: function get() {\n      return this._maxSize;\n    }\n    /**\n     * Set maximum size of pool. If this is set after construction it follows these rules:\n     * - If the pool size is INCREASING: more audio segments will be created and added to the pool\n     * - If the pool size is DECREASING: unused audio segments will be removed until the total number of segments equals the new max size.\n     * If there are no unused audio segments to remove (or not enough to satisfy the new size), you will not be able to retrieve new segments\n     * until the currently used segments are returned to the pool.\n     *\n     * @memberof AudioSegmentPool\n     */\n    ,\n    set: function set(newSize) {\n      if (typeof newSize !== 'number') {\n        throw new TypeError(\"Expected maxSize to be a number. Received \".concat(_typeof(newSize), \" \"));\n      }\n\n      var delta = newSize - this._maxSize;\n      var cappedDelta = delta < 0 ? Math.max(delta, -1 * this._availableSegments.length) : delta;\n\n      for (var i = 0; i < Math.abs(cappedDelta); i++) {\n        if (delta < 0) {\n          this._availableSegments.shift();\n        }\n\n        if (delta > 0) {\n          var audioSegment = new _AudioSegment__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this._context, this._destNode, generateRandomString());\n          audioSegment.unload(); // Keep each audio segment unloaded to start\n\n          this._availableSegments.push(audioSegment);\n        }\n      }\n\n      this._maxSize = newSize;\n    }\n  }, {\n    key: \"availableSegmentCount\",\n    get: function get() {\n      return this._availableSegments.length;\n    }\n  }]);\n\n  return AudioSegmentPool;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (AudioSegmentPool);\n\n//# sourceURL=webpack://Sonorous/./Sonor/AudioSegmentPool.js?");

/***/ }),

/***/ "./Sonor/BufferCache/AxiosDownloadTask.js":
/*!************************************************!*\
  !*** ./Sonor/BufferCache/AxiosDownloadTask.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AxiosDownloadTask; });\n/* harmony import */ var axios_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios-retry */ \"../node_modules/axios-retry/index.js\");\n/* harmony import */ var axios_retry__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios_retry__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"../node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\nvar CancelToken = axios__WEBPACK_IMPORTED_MODULE_1___default.a.CancelToken;\n/**\n * A wrapper over an XMLHttpRequest that returns a promise\n *\n * @export\n * @class AxiosDownloadTask\n */\n\nvar AxiosDownloadTask = /*#__PURE__*/function () {\n  function AxiosDownloadTask(url) {\n    _classCallCheck(this, AxiosDownloadTask);\n\n    axios_retry__WEBPACK_IMPORTED_MODULE_0__(axios__WEBPACK_IMPORTED_MODULE_1___default.a, {\n      retries: 3\n    });\n    this._url = url;\n    this._source = CancelToken.source();\n    this._downloadPromise = null;\n  }\n  /**\n   * Public read-only property to get the url that will be downloaded\n   *\n   * @readonly\n   * @memberof AxiosDownloadTask\n   */\n\n\n  _createClass(AxiosDownloadTask, [{\n    key: \"start\",\n\n    /**\n     * Sends an XHR request and returns a promise. When resolved, the promise\n     * will pass in the encoded buffer. If it fails, it will pass the error\n     * message through to the rejection.\n     * @returns\n     * @memberof AxiosDownloadTask\n     */\n    value: function start() {\n      var _this = this;\n\n      var options = {\n        cancelToken: this._source.token,\n        responseType: 'arraybuffer'\n      };\n      this._downloadPromise = axios__WEBPACK_IMPORTED_MODULE_1___default.a.get(this._url, options).then(function (response) {\n        _this._downloadPromise = null;\n        return response.data;\n      }).catch(function (error) {\n        if (axios__WEBPACK_IMPORTED_MODULE_1___default.a.isCancel(error)) {\n          var e = new Error('Request Cancelled');\n          e.code = 99;\n          throw e;\n        } else {\n          throw new Error(error.message);\n        }\n      });\n    }\n    /**\n     * Will abort the xhr request if one exists.\n     *\n     * @memberof AxiosDownloadTask\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._source.cancel();\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this._url;\n    }\n    /**\n     * Public, read-only property to get the promise associated with this task.\n     * If we have not started the download, or if we have completed the download,\n     * this will be null.\n     *\n     * @readonly\n     * @memberof AxiosDownloadTask\n     */\n\n  }, {\n    key: \"bufferPromise\",\n    get: function get() {\n      return this._downloadPromise;\n    }\n  }]);\n\n  return AxiosDownloadTask;\n}();\n\n\n\n//# sourceURL=webpack://Sonorous/./Sonor/BufferCache/AxiosDownloadTask.js?");

/***/ }),

/***/ "./Sonor/BufferCache/BufferCacheItem.js":
/*!**********************************************!*\
  !*** ./Sonor/BufferCache/BufferCacheItem.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BufferCacheItem; });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"../node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/**\n * BufferCacheItem is a generic class that both the DecodedBufferCache and EncodedBufferCache use.\n * The BufferCacheItem contains a task, that when started, will return a promise/resolve into a buffer.\n * It also keeps track of its references and will emit an event when there are no more references to it.\n * It is up to the cache to remove this element when it no longer has any references.\n *\n * @export\n * @class BufferCacheItem\n * @extends {EventEmitter}\n */\n\nvar BufferCacheItem = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(BufferCacheItem, _EventEmitter);\n\n  var _super = _createSuper(BufferCacheItem);\n\n  /**\n   * Creates an instance of BufferCacheItem. BufferCacheItem extends EventEmitter\n   * so it can send events.\n   * @param {string} url - the URL associated with the buffer\n   * @param {BufferTask} loadingTask - The task that can be started, canceled, and will resolve with a buffer. See DecodeBufferTask or AxiosDownloadTask for the necessary methods/properties.\n   * @memberof BufferCacheItem\n   */\n  function BufferCacheItem(url, loadingTask) {\n    var _this;\n\n    _classCallCheck(this, BufferCacheItem);\n\n    _this = _super.call(this); // Param validity checks\n\n    if (!url) {\n      throw new Error('Missing required url');\n    }\n\n    if (typeof url !== 'string') {\n      throw new TypeError('Url must be a string');\n    }\n\n    if (!loadingTask) {\n      throw new Error('Missing required loading task');\n    }\n\n    if (typeof loadingTask.start !== 'function') {\n      throw new Error('Expected a start function for task');\n    }\n\n    if (typeof loadingTask.cancel !== 'function') {\n      throw new Error('Expected a cancel function for task');\n    }\n\n    if (_typeof(loadingTask.bufferPromise) !== 'object') {\n      throw new Error('Expected a request property for task');\n    }\n\n    _this._url = url;\n    _this._buffer = null;\n    _this._task = loadingTask;\n    _this._bufferPromise = null;\n    _this._refCount = 1;\n    return _this;\n  }\n\n  _createClass(BufferCacheItem, [{\n    key: \"copyArrayBuffer\",\n    value: function copyArrayBuffer(buffer) {\n      if (buffer && buffer instanceof ArrayBuffer) {\n        return buffer.slice(0);\n      }\n\n      return buffer;\n    }\n    /**\n     * If we already have the buffer, we will return it. If we don't have the buffer, we will return a promise that will resolve with the buffer.\n     *\n     * @readonly\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"startTask\",\n\n    /**\n     * This will call start() on the task, and return a promise that will resolve into the buffer\n     *\n     * @returns\n     * @memberof BufferCacheItem\n     */\n    value: function startTask() {\n      if (this._task) {\n        this._task.start();\n\n        this._bufferPromise = this._task.bufferPromise.then(this.onSuccess.bind(this), this.onFailure.bind(this));\n      }\n    }\n    /**\n     * Increment the ref count of this cache item by 1\n     *\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"addRef\",\n    value: function addRef() {\n      if (this._refCount > 0) {\n        this._refCount += 1;\n      } else {\n        this.emit('error', new Error('Attempted to add refs after item has been released'), this._url);\n      }\n    }\n    /**\n     * Decrement the ref count of this cache item by 1. If the ref count hits 0, emit a \"nomorerefs\" event.\n     *\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"removeRef\",\n    value: function removeRef() {\n      this._refCount -= 1;\n\n      if (this._refCount === 0) {\n        if (this._task) {\n          this._task.cancel();\n        }\n\n        this._buffer = null;\n        this._task = null;\n        this.emit('nomorerefs', this._url);\n      }\n    }\n    /**\n     * Cancel a task if so desired.\n     *\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this._task) {\n        this._task.cancel();\n      }\n    }\n    /**\n     * If the task's promise successfully resolves, store the buffer and nullify the task.\n     *\n     * @param {*} buf\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"onSuccess\",\n    value: function onSuccess(buf) {\n      this._buffer = buf;\n      this._task = null;\n      return this.copyArrayBuffer(this._buffer);\n    }\n    /**\n     * If the task's promise failed, emit an error.\n     *\n     * @param {*} error\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"onFailure\",\n    value: function onFailure(error) {\n      if (error.code && error.code === 99 && error.message === 'Request Cancelled') {\n        // eslint-disable-line no-magic-numbers\n        this.emit('requestcancelled', this._url);\n        this._task = null;\n        this._buffer = null;\n      } else {\n        this._task = null;\n        this._buffer = null;\n        this.emit('error', error, this._url);\n        throw error;\n      }\n    }\n  }, {\n    key: \"bufferPromise\",\n    get: function get() {\n      if (this._buffer) {\n        return Promise.resolve(this.copyArrayBuffer(this._buffer));\n      }\n\n      return this._bufferPromise;\n    }\n    /**\n     * Based on the presence of the buffer or the task, we can determine the loading state of this item.\n     * The state can be one of 3 values - 'loading', 'loaded', or 'failed'.\n     *\n     * @readonly\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      var retVal = '';\n\n      if (this._buffer === null && this._task === null) {\n        retVal = 'failed';\n      } else if (this._buffer === null && this._task !== null) {\n        retVal = 'pending';\n      } else if (this._buffer !== null && this._task === null) {\n        retVal = 'loaded';\n      }\n\n      return retVal;\n    }\n    /**\n     * Returns the number of references to this cache item\n     *\n     * @readonly\n     * @memberof BufferCacheItem\n     */\n\n  }, {\n    key: \"refs\",\n    get: function get() {\n      return this._refCount;\n    }\n  }]);\n\n  return BufferCacheItem;\n}(eventemitter3__WEBPACK_IMPORTED_MODULE_0___default.a);\n\n\n\n//# sourceURL=webpack://Sonorous/./Sonor/BufferCache/BufferCacheItem.js?");

/***/ }),

/***/ "./Sonor/BufferCache/DecodeBufferTask.js":
/*!***********************************************!*\
  !*** ./Sonor/BufferCache/DecodeBufferTask.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DecodeBufferTask; });\n/* harmony import */ var _EncodedBufferCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EncodedBufferCache */ \"./Sonor/BufferCache/EncodedBufferCache.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n/**\n * A wrapper over an XMLHttpRequest that returns a promise\n *\n * @export\n * @class DecodeBufferTask\n */\n\nvar DecodeBufferTask = /*#__PURE__*/function () {\n  function DecodeBufferTask(url, audioContext) {\n    _classCallCheck(this, DecodeBufferTask);\n\n    this._bufferPromise = null;\n    this._url = url;\n    this._audioContext = audioContext;\n    this._encodedBufCache = _EncodedBufferCache__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance;\n  }\n  /**\n   * Public read-only property to get the url that will be downloaded\n   *\n   * @readonly\n   * @memberof DecodeBufferTask\n   */\n\n\n  _createClass(DecodeBufferTask, [{\n    key: \"start\",\n\n    /**\n     * Sends an XHR request and returns a promise. When resolved, the promise\n     * will pass in the encoded buffer. If it fails, it will pass the error\n     * message through to the rejection.\n     * @returns\n     * @memberof DecodeBufferTask\n     */\n    value: function start() {\n      var _this = this;\n\n      this._bufferPromise = this._encodedBufCache.getEncodedBuffer(this._url).then(function (encodedBuffer) {\n        if (encodedBuffer) {\n          return _this.decodeAudioData(encodedBuffer, _this._url, _this._audioContext);\n        }\n      });\n    }\n    /**\n     * Will return a promise that should resolve with the decoded buffer. This will also\n     * handle saving to cache if indicated, and storing ref counts.\n     *\n     * @param {*} buffer - the **encoded** buffer returned from the download manager\n     * @param {String} url - the url associated with the buffer. Used to update the caches.\n     * @param {AudioContext} audioContext - WebAudio audio context\n     * @returns {Promise} A promise that should resolve with the decoded buffer.\n     * @memberof DecodedBufferCache\n     */\n\n  }, {\n    key: \"decodeAudioData\",\n    value: function decodeAudioData(buffer, url, audioContext) {\n      // Bail out if we don't have the audioContext. Can't decode without it.\n      if (!audioContext) {\n        var errMsg = 'Missing AudioContext - cannot decode the audio buffer';\n        return Promise.reject(new Error(errMsg));\n      } // Return a promise that resolves with the decoded buffer\n\n\n      return new Promise(function (resolve, reject) {\n        // Define the success function\n        var decodeSuccess = function decodeSuccess(decodedBuffer) {\n          resolve(decodedBuffer);\n        }; // Define the failure function\n\n\n        var decodeFail = function decodeFail(error) {\n          // Report the error and reject\n          var errMsg = \"Decoding the audio data failed. \".concat(error);\n          reject(new Error(errMsg));\n        }; // Actually make the call to decode the audio data\n\n\n        var promiseRetVal = audioContext.decodeAudioData(buffer, decodeSuccess, decodeFail); // If the decodeAudioData call does return a promise, use a then block.\n\n        if (promiseRetVal && typeof promiseRetVal.then === 'function') {\n          promiseRetVal.then(decodeSuccess, decodeFail);\n        }\n      });\n    }\n    /**\n     * Will abort the xhr request if one exists.\n     *\n     * @memberof AxiosDownloadTask\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._encodedBufCache.cancelDownloadTask(this._url);\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this._url;\n    }\n    /**\n     * Public, read-only property to get the promise associated with this task.\n     * If we have not started the download, or if we have completed the download,\n     * this will be null.\n     *\n     * @readonly\n     * @memberof DecodeBufferTask\n     */\n\n  }, {\n    key: \"bufferPromise\",\n    get: function get() {\n      return this._bufferPromise;\n    }\n  }]);\n\n  return DecodeBufferTask;\n}();\n\n\n\n//# sourceURL=webpack://Sonorous/./Sonor/BufferCache/DecodeBufferTask.js?");

/***/ }),

/***/ "./Sonor/BufferCache/DecodedBufferCache.js":
/*!*************************************************!*\
  !*** ./Sonor/BufferCache/DecodedBufferCache.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DecodedBufferCache; });\n/* harmony import */ var _EncodedBufferCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EncodedBufferCache */ \"./Sonor/BufferCache/EncodedBufferCache.js\");\n/* harmony import */ var _BufferCacheItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferCacheItem */ \"./Sonor/BufferCache/BufferCacheItem.js\");\n/* harmony import */ var _DecodeBufferTask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DecodeBufferTask */ \"./Sonor/BufferCache/DecodeBufferTask.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n/**\n * This is the main interface between downloading/decoding a buffer and returning it to the Sonor class.\n * The Sonor object will request the buffer from the DecodedBufferCache (a singleton). If this class\n * does not have the decoded buffer cached, it will ask the EncodedBufferCache for the encoded buffer.\n * If the EncodedBufferCache does not have the encoded buffer cached, then it will attempt to download it.\n * Once the DecodedBufferCache has the encoded buffer, it will attempt to decode it, and cache it.\n *\n * The Sonor obj can determine whether or not the decoded buffer will be cached or not. **If the decoded\n * buffer is not cached, the encoded buffer will be.** Both caches are ref counted, and the buffers will\n * be removed from cache when it hits 0 refs. Not caching the buffer will use less memory, but there may\n * be a delay when attempting to play.\n *\n * It is the Sonor's responsibility to call removeRef() when it no longer intends to use the buffer.\n *\n * @export\n * @class DecodedBufferCache\n */\n\nvar DecodedBufferCache = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of DecodedBufferCache. This class is a singleton.\n   *\n   * @memberof DecodedBufferCache\n   */\n  function DecodedBufferCache() {\n    _classCallCheck(this, DecodedBufferCache);\n\n    this._bufferCache = {};\n    this._decodedBufferCache = {};\n    this._currentlyDecoding = {};\n    this._encodedBufCache = _EncodedBufferCache__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance;\n  }\n  /**\n   * Retrieves the instance of the decodedbuffercache.\n   *\n   * @readonly\n   * @static\n   * @memberof DecodedBufferCache\n   */\n\n\n  _createClass(DecodedBufferCache, [{\n    key: \"getDecodedBuffer\",\n\n    /**\n     * Responsible for decoding an encoded buffer, caching it (if desired), and\n     * returning a promise that will resolve to the decoded buffer. This also\n     * handles incrementing ref counts, so we can properly dispose of it in the\n     * future.\n     *\n     * @param {String} url - _Required._ The URL of the audio file that should be decoded\n     * @param {Object} audioContext - _Required._ The WebAudio AudioContext that will decode the buffer. This is necessary if we happen to not have the decoded buffer in the cache.\n     * @param {Boolean} [saveToCache = False] - _Optional._ If true, it will save the decoded buffer to the cache.\n     * @returns {Promise} A promise that will resolve with the decoded buffer\n     * @memberof DecodedBufferCache\n     */\n    value: function getDecodedBuffer(url, audioContext, saveToCache) {\n      var _this = this;\n\n      // Check validity of params\n      if (!url) {\n        return Promise.reject(new Error('Missing required url'));\n      }\n\n      if (!audioContext) {\n        return Promise.reject(new Error('Missing required audio context'));\n      }\n\n      if (typeof url !== 'string') {\n        return Promise.reject(new TypeError('url must be a string'));\n      }\n\n      if (saveToCache) {\n        if (typeof saveToCache !== 'boolean') {\n          return Promise.reject(new TypeError('saveToCache must be a boolean'));\n        }\n      } // Check if a cache item already exists for this url\n\n\n      if (this._bufferCache[url]) {\n        // If it exists and hasn't errored out, return the buffer\n        if (this._bufferCache[url].status !== 'failed') {\n          this._bufferCache[url].addRef(); // If the buffer is still downloading/being decoded, then this will return a promise that will resolve with the decoded buffer\n\n\n          return this._bufferCache[url].bufferPromise;\n        }\n      } // It's not in our cache, which means we don't have the decoded buffer and we're not in the process of downloading/decoding it.\n      // Create a new cache item with a task for this url.\n\n\n      var cacheItem = this.createCacheItem(url, audioContext); // The cache item will handle getting the encoded buffer from the download manager, decoding and returning it.\n\n      cacheItem.startTask(); // Add the cache item to the cache (it will have a ref count of 1)\n\n      this._bufferCache[url] = cacheItem; // Return the promise from the cache item\n\n      return cacheItem.bufferPromise.then(function (decodedBuffer) {\n        if (saveToCache) {\n          // If we're saving the decoded buffer to cache, remove the encoded buffer\n          _this._encodedBufCache.removeRef(url);\n        } else {\n          // If we're not saving the decoded buffer to cache, remove from the decoded buffer cache\n          delete _this._bufferCache[url];\n        }\n\n        return decodedBuffer;\n      });\n    }\n    /**\n     * Creates an instance of BufferCacheItem, assigns its task, and sets up listeners on it.\n     *\n     * @param {string} url\n     * @param {AudioContext} audioContext\n     * @returns {BufferCacheItem}\n     * @memberof DecodedBufferCache\n     */\n\n  }, {\n    key: \"createCacheItem\",\n    value: function createCacheItem(url, audioContext) {\n      var _this2 = this;\n\n      // Create a task to decode a buffer. This will handle retrieving the buffer from the download manager and decoding it.\n      var currTask = new _DecodeBufferTask__WEBPACK_IMPORTED_MODULE_2__[\"default\"](url, audioContext); // Create a buffer cache item and set its task to the one created above.\n\n      var newCacheItem = new _BufferCacheItem__WEBPACK_IMPORTED_MODULE_1__[\"default\"](url, currTask, 'decode'); // Add listeners for when the ref count goes down to 0, and for errors\n\n      newCacheItem.once('nomorerefs', function (taskUrl) {\n        if (_this2._bufferCache[taskUrl]) {\n          _this2._bufferCache[taskUrl].cancel();\n\n          delete _this2._bufferCache[taskUrl];\n        }\n      });\n      newCacheItem.on('error', function (error, taskUrl) {\n        if (_this2._bufferCache[taskUrl]) {\n          delete _this2._bufferCache[taskUrl];\n        }\n      });\n      return newCacheItem;\n    }\n    /**\n     * Remove a reference to a decoded buffer. If the ref count hits 0,\n     * remove the decoded buffer from the cache entirely.\n     *\n     * @param {String} url - the url associated to the decoded buffer\n     * @memberof DecodedBufferCache\n     */\n\n  }, {\n    key: \"removeRef\",\n    value: function removeRef(url) {\n      // If we do have the decoded buffer, remove a ref\n      if (this._bufferCache[url]) {\n        this._bufferCache[url].removeRef();\n      } else {\n        // Otherwise, remove a ref from the download manager\n        this._encodedBufCache.removeRef(url);\n      }\n    }\n    /**\n     * This will completely erase both the currently decoding cache and the decoded buffer cache.\n     *\n     * @memberof DecodedBufferCache\n     */\n\n  }, {\n    key: \"purgeCache\",\n    value: function purgeCache() {\n      this._bufferCache = {};\n    }\n  }], [{\n    key: \"instance\",\n    get: function get() {\n      if (!this._instance) {\n        this._instance = new DecodedBufferCache();\n      }\n\n      return this._instance;\n    }\n  }]);\n\n  return DecodedBufferCache;\n}();\n\n\n\n//# sourceURL=webpack://Sonorous/./Sonor/BufferCache/DecodedBufferCache.js?");

/***/ }),

/***/ "./Sonor/BufferCache/EncodedBufferCache.js":
/*!*************************************************!*\
  !*** ./Sonor/BufferCache/EncodedBufferCache.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EncodedBufferCache; });\n/* harmony import */ var _AxiosDownloadTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosDownloadTask */ \"./Sonor/BufferCache/AxiosDownloadTask.js\");\n/* harmony import */ var _BufferCacheItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferCacheItem */ \"./Sonor/BufferCache/BufferCacheItem.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n/**\n * A singleton class that maintains a cache of **encoded**\n * audio buffers and spawns download tasks for new URLs.\n *\n * @export\n * @class EncodedBufferCache\n */\n\nvar EncodedBufferCache = /*#__PURE__*/function () {\n  function EncodedBufferCache() {\n    _classCallCheck(this, EncodedBufferCache);\n\n    this._bufferCache = {};\n  }\n\n  _createClass(EncodedBufferCache, [{\n    key: \"getEncodedBuffer\",\n\n    /**\n     * Creates a download task and begins the download process.\n     * If it already has a buffer for that url in the cache, it will\n     * resolve immediately with the cached buffer. If the url is\n     * currently downloading, it will return the promise from the\n     * first download task to request it.\n     *\n     * @param {String} url\n     * @returns A promise that will resolve with the decoded buffer\n     * @memberof EncodedBufferCache\n     */\n    value: function getEncodedBuffer(url) {\n      if (typeof url !== 'string') {\n        throw new TypeError('Expected url to be a string');\n      } // If we already have an encoded buffer in the cache for this URL, then resolve immediately with it.\n\n\n      if (this._bufferCache[url]) {\n        // If we haven't errored out, then return the promise if we're currently loading or the buffer if we've finished loading\n        if (this._bufferCache[url].status !== 'failed') {\n          this._bufferCache[url].addRef();\n\n          return this._bufferCache[url].bufferPromise;\n        }\n      } // Otherwise, create a cache item for this url\n\n\n      var cacheItem = this.createCacheItem(url); // Start the download and return\n\n      cacheItem.startTask();\n      this._bufferCache[url] = cacheItem;\n      return this._bufferCache[url].bufferPromise;\n    }\n  }, {\n    key: \"createCacheItem\",\n    value: function createCacheItem(url) {\n      var _this = this;\n\n      // Create a new download task\n      var downloadTask = new _AxiosDownloadTask__WEBPACK_IMPORTED_MODULE_0__[\"default\"](url); // Create a new cache item with the download as its task\n\n      var newCacheItem = new _BufferCacheItem__WEBPACK_IMPORTED_MODULE_1__[\"default\"](url, downloadTask, 'download'); // Add listeners for no more refs, or if an error occurs during download\n\n      newCacheItem.once('nomorerefs', function (taskUrl) {\n        if (_this._bufferCache[taskUrl]) {\n          if (_this._bufferCache[taskUrl].state === 'loading') {\n            _this._bufferCache[taskUrl].cancel();\n          }\n\n          delete _this._bufferCache[taskUrl];\n        }\n      });\n      newCacheItem.on('error', function (error, taskUrl) {\n        if (_this._bufferCache[taskUrl]) {\n          delete _this._bufferCache[taskUrl];\n        }\n      });\n      return newCacheItem;\n    }\n    /**\n     * If a download task for the given url is still downloading, then\n     * cancel the task.\n     *\n     * @param {String} url\n     * @memberof EncodedBufferCache\n     */\n\n  }, {\n    key: \"cancelDownloadTask\",\n    value: function cancelDownloadTask(url) {\n      if (this._bufferCache[url]) {\n        this._bufferCache[url].cancel();\n\n        delete this._bufferCache[url];\n      }\n    }\n    /**\n     * Get the status of a download task. Return value will either be:\n     * - 'loaded' (in the cache already)\n     * - 'loading' (currently downloading)\n     * - 'unloaded' (no task exists for this url)\n     *\n     * @param {String} url\n     * @returns 'loaded', 'loading', or 'failed'\n     * @memberof EncodedBufferCache\n     */\n\n  }, {\n    key: \"getStatus\",\n    value: function getStatus(url) {\n      if (this._bufferCache[url]) {\n        return this._bufferCache[url].state;\n      }\n    }\n    /**\n     * This will remove the entire cache.\n     *\n     * @memberof EncodedBufferCache\n     */\n\n  }, {\n    key: \"purgeCache\",\n    value: function purgeCache() {\n      this._bufferCache = {};\n    }\n    /**\n     * This will remove an encoded buffer from the cache if it exists, or\n     * cancel the download if the url is currently downloading.\n     *\n     * @param {String} url\n     * @memberof EncodedBufferCache\n     */\n\n  }, {\n    key: \"removeRef\",\n    value: function removeRef(url) {\n      if (this._bufferCache[url]) {\n        this._bufferCache[url].removeRef();\n      }\n    }\n  }], [{\n    key: \"instance\",\n    get: function get() {\n      if (!this._instance) {\n        this._instance = new EncodedBufferCache();\n      }\n\n      return this._instance;\n    }\n  }]);\n\n  return EncodedBufferCache;\n}();\n\n\n\n//# sourceURL=webpack://Sonorous/./Sonor/BufferCache/EncodedBufferCache.js?");

/***/ }),

/***/ "./Sonor/Sonor.js":
/*!************************!*\
  !*** ./Sonor/Sonor.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AudioSegment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AudioSegment */ \"./Sonor/AudioSegment.js\");\n/* harmony import */ var _AudioSegmentPool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AudioSegmentPool */ \"./Sonor/AudioSegmentPool.js\");\n/* harmony import */ var _utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/copySetterGetterFromInstance */ \"./utils/copySetterGetterFromInstance.js\");\n/* harmony import */ var _BufferCache_DecodedBufferCache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BufferCache/DecodedBufferCache */ \"./Sonor/BufferCache/DecodedBufferCache.js\");\n/* harmony import */ var _utils_validateSourcesHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/validateSourcesHelper */ \"./utils/validateSourcesHelper.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventemitter3 */ \"../node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_5__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n // eslint-disable-line\n\n\n\n\n\n\nvar defaultPoolSize = 1;\n/**\n * This module contains most of the functionality for controlling sounds.\n * Note that this module will only use WebAudio. If WebAudio is not supported,\n * you will not be able to use this library.\n *\n * @export\n * @class Sonor\n */\n\nvar Sonor = /*#__PURE__*/function () {\n  /**\n   * @typedef {Object} SonorSrc\n   * @property {string} url - Required. The src url of the sound.\n   * @property {string} format - Required. The format of the audio file\n   */\n\n  /**\n   * @typedef {Object} Sprite\n   * key : {offset: Number, duration: Number, isLooping: boolean}\n   */\n\n  /**\n   * Creates an instance of Sonor.\n   * @param {string|string[]|SonorSrc|SonorSrc[]} src - Required. The src URL(s) of the sound.\n   * @param {WebAudioNode} destNode - Required. The node to connect the gain node to.\n   * @param {AudioContext} audioContext - Required. The AudioContext is needed to create audio nodes, etc.\n   * @param {object} [options] - An object used to configure Sonor.\n   * @param {string} [options.id] - Optional. A unique ID will be created for this object if you do not pass one in.\n   * @param {boolean} [options.preload = True] - Optional. Defaults to true and will automatically attempt to load the sound src URL. If false, then it's up to the calling code to load the sound.\n   * @param {Number} [options.volume = 1.0] - Optional. Defaults to 1.0 and will set the initial volume of the sound.\n   * @param {boolean} [options.loop = False] - Optional. Defaults to false and will determine if the audio should loop forever or not.\n   * @param {boolean} [options.autoplay = False] - Optional. Defaults to false. Will determine if the audio should try to play as soon as its loaded.\n   * @param {boolean} [options.muted = False] - Optional. Defaults to false. Will determine if the audio should be muted on load or not.\n   * @param {Sprite} [options.sprite] - Optional. Not implemented yet. This is an object that should define sections of audio that will play at different times.\n   * @param {Number} [options.poolSize = 1] - Optional. Defaults to 1, and will set the size of the pool for this sonor. Increase the size of the pool if you would like to start playing the same sound multiple times, before the first playthrough is finished.\n   * @param {string} [options.optimizeFor = 'time'] - Optional. Can either be 'time' or 'memory'. This determines if the decoded buffer will be cached or not. By default, it will be. If memory is a concern, then set this to 'memory' and expect a small delay while we decode the buffer before playback can begin.\n   * @memberof Sonor\n   */\n  function Sonor(src, destNode, audioContext, options) {\n    _classCallCheck(this, Sonor);\n\n    if (!src) {\n      throw new Error(\"Can't construct Sonor - missing \\\"src\\\" value\");\n    }\n\n    if (!destNode) {\n      throw new Error(\"Can't construct Sonor - missing destination node\");\n    }\n\n    if (!audioContext) {\n      throw new Error(\"Can't construct Sonor - missing audio context\");\n    }\n\n    this._eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_5___default.a(); // Determine the first, valid URL. This will be what we download and use to play.\n\n    this._url = _utils_validateSourcesHelper__WEBPACK_IMPORTED_MODULE_4__[\"default\"].chooseValidURL(_utils_validateSourcesHelper__WEBPACK_IMPORTED_MODULE_4__[\"default\"].normalizeSrc(src));\n\n    if (!this._url) {\n      throw new Error(\"Can't construct Sonor - invalid src value \".concat(src));\n    } // Create a download manager\n\n\n    this._decodedBufferCache = _BufferCache_DecodedBufferCache__WEBPACK_IMPORTED_MODULE_3__[\"default\"].instance; // Initialize private properties\n\n    this._context = audioContext;\n    this.initializeOptions(options, destNode);\n    this._playQueued = false;\n\n    if (this._preload) {\n      this._activeSegments.push(this._segmentPool.retrieve());\n\n      this.load();\n    }\n\n    if (this._autoplay) {\n      this.play();\n    }\n\n    this.exportPublicAPI();\n    return this.exports;\n  } /////////////////////////\n  // PROPERTIES\n  ////////////////////////\n\n  /**\n   * Controls the volume of the sound\n   * @name Sonor#volume\n   * @type Number\n   * @default 1.0\n   * @memberof Sonor\n   */\n\n\n  _createClass(Sonor, [{\n    key: \"play\",\n    /////////////////////////\n    // PUBLIC FUNCTIONS\n    ////////////////////////\n\n    /**\n     * Tells the audio segment to begin playing. This will also set isPlaying to true.\n     * If the pool of audio segments is greater than 1, the logic is as follows:\n     *  If there are no active segments, one will be retrieved from the pool, and then played.\n     *  If there are active segments, but none are currently playing, all currently active segments will be played. (i.e. if they were paused, then these sounds will resume playback, and nothing will be retrieved from the pool).\n     *  If there are no available segments in the pool, then playing will do nothing and will report an error.\n     *\n     * @memberof Sonor\n     */\n    value: function play() {\n      var _this = this;\n\n      if (this._activeSegments.length === 0 || this.isPlaying || this._playQueued) {\n        // If every currently active audio segment is playing, then try to grab one from the pool or if there are no currently active segments, then grab one from the pool\n        if (this._segmentPool.canRetrieve()) {\n          var poolSegment = this._segmentPool.retrieve();\n\n          if (poolSegment) {\n            this._playQueued = true;\n            this.loadSegment(poolSegment).then(function () {\n              _this._activeSegments.push(poolSegment);\n\n              poolSegment.play();\n              _this._playQueued = false;\n            });\n          }\n        } else {\n          this.trigger('error', 'No sounds in the pool available. Please pause/stop or wait until it has ended, or increase the pool size.'); // eslint-disable-line max-len\n        }\n      } else {\n        // Otherwise, call play on every active audio segment\n        this._activeSegments.forEach(function (segment) {\n          _this._playQueued = true;\n\n          _this.loadSegment(segment).then(function () {\n            if (_this._state !== 'unloaded') {\n              segment.play();\n              _this._playQueued = false;\n            }\n          });\n        });\n      }\n    }\n    /**\n     * Tells all active audio segments to pause. This will also set isPlaying to false.\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var _this2 = this;\n\n      if (this._playQueued) {\n        this.once('play', function () {\n          _this2._activeSegments.forEach(function (segment) {\n            segment.pause();\n          });\n        });\n      } else {\n        this._activeSegments.forEach(function (segment) {\n          segment.pause();\n        });\n      }\n    }\n    /**\n     * Tells all active audio segments to stop. This will also set isPlaying to false.\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this3 = this;\n\n      if (this._playQueued) {\n        this.once('play', function () {\n          _this3._activeSegments.forEach(function (segment) {\n            segment.once('stop', function () {\n              var index = _this3._activeSegments.indexOf(segment);\n\n              if (index >= 0) {\n                _this3._activeSegments.splice(index, 1);\n              }\n\n              _this3._segmentPool.returnSegment(segment);\n            });\n            segment.stop();\n          });\n\n          _this3._activeSegments = [];\n        });\n      } else {\n        this._activeSegments.forEach(function (segment) {\n          segment.stop();\n\n          _this3._segmentPool.returnSegment(segment);\n        });\n\n        this._activeSegments = [];\n      }\n    }\n    /**\n     * Seeks to a new position in all active audio segments. If called after playback has already started,\n     * it will automatically move to the new point in the audio. If called before playback,\n     * playback will start at that point. If the sonor is looping and the position passed in is greater than the\n     * sonor's duration, the position will be looped to fit within the sonor duration.\n     *\n     * @param {Number} newSeekPosition\n     * @memberof Sonor\n     * @example\n     * console.log(sonor.duration); // 10\n     * sonor.loop = true;\n     * sonor.seek(35);\n     * console.log(sonor.playbackPosition); // 5\n     */\n\n  }, {\n    key: \"seek\",\n    value: function seek(newSeekPosition) {\n      this._activeSegments.forEach(function (segment) {\n        segment.seek(newSeekPosition);\n      });\n    }\n    /**\n     * Fades from one volume to another volume over a specified duration. There is an optional\n     * startTime parameter, which can be used to schedule a fade. startTime is relative to the\n     * beginning of the audio, not to the context time. If the startTime passed in is before\n     * our current position in the audio, then we will linearly interpolate to figure out\n     * what volume the audio should be at at the current time, and start the fade immediately.\n     * This is applied to all active audio segments.\n     *\n     * @param {Number} stopVolume\n     * @param {Number} fadeDuration - the fade duration in seconds\n     * @param {Number} startTime\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"fade\",\n    value: function fade(stopVolume, fadeDuration, startTime) {\n      this._activeSegments.forEach(function (segment) {\n        segment.fade(stopVolume, fadeDuration, startTime);\n      });\n    }\n    /**\n     * Event emitter function that will let a module register a callback for a specified event issued from\n     * the Sonor.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      this._eventEmitter.on(eventName, callback);\n    }\n    /**\n     * Event emitter function that will let a module remove a callback for a specified event issued from\n     * the Sonor.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, callback) {\n      this._eventEmitter.off(eventName, callback);\n    }\n    /**\n     * Event emitter function that will let a module register a callback for a specified event\n     * from the Sonor. The callback will only be called once, while the event may\n     * be emitted more than once.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(eventName, callback) {\n      this._eventEmitter.once(eventName, callback);\n    } /////////////////////////\n    // PRIVATE FUNCTIONS\n    ////////////////////////\n\n    /**\n     * Private function. Will set up listeners for the audio segment events\n     * and will forward them\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"setUpAudioSegmentListeners\",\n    value: function setUpAudioSegmentListeners(segment) {\n      segment.on('play', this.onPlay.bind(this));\n      segment.on('error', this.onError.bind(this));\n      segment.on('pause', this.onPause.bind(this));\n      segment.on('ended', this.onEnded.bind(this));\n      segment.on('stop', this.onStop.bind(this));\n      segment.on('volumechanged', this.onVolumeChanged.bind(this));\n      segment.on('seeked', this.onSeekedTo.bind(this));\n      segment.on('fadefinished', this.onFadeFinished.bind(this));\n      segment.on('playbackratechanged', this.onPlaybackRateChanged.bind(this));\n    }\n    /**\n     * Private function. Will remove listeners for the audio segment events\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"removeAudioSegmentListeners\",\n    value: function removeAudioSegmentListeners(segment) {\n      segment.off('play', this.onPlay.bind(this));\n      segment.off('error', this.onError.bind(this));\n      segment.off('pause', this.onPause.bind(this));\n      segment.off('ended', this.onEnded.bind(this));\n      segment.off('stop', this.onStop.bind(this));\n      segment.off('volumechanged', this.onVolumeChanged.bind(this));\n      segment.off('seeked', this.onSeekedTo.bind(this));\n      segment.off('fadefinished', this.onFadeFinished.bind(this));\n      segment.off('playbackratechanged', this.onPlaybackRateChanged.bind(this));\n    }\n    /**\n     * Private function. Will emit an event and pass the sonor instance\n     * as one of the arguments, along with any other args specified.\n     *\n     * @param {*} eventName\n     * @param {*} args\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"trigger\",\n    value: function trigger(eventName) {\n      var _this$_eventEmitter;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (_this$_eventEmitter = this._eventEmitter).emit.apply(_this$_eventEmitter, [eventName, this.exports].concat(args));\n    }\n    /**\n     * Private functions. The following functions all listen to AudioSegment events\n     * and forward them on.\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"onPlay\",\n    value: function onPlay() {\n      this.trigger('play');\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(segment, error) {\n      this.trigger('error', error);\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {\n      this.trigger('pause');\n    }\n  }, {\n    key: \"onStop\",\n    value: function onStop() {\n      this.trigger('stop');\n    }\n  }, {\n    key: \"onEnded\",\n    value: function onEnded(segment) {\n      var _this4 = this;\n\n      // This segment is now inactive - return to the pool\n      var foundSegmentIndex = this._activeSegments.indexOf(segment);\n\n      if (foundSegmentIndex >= 0) {\n        var removedSegments = this._activeSegments.splice(foundSegmentIndex, 1);\n\n        removedSegments.forEach(function (seg) {\n          _this4._segmentPool.returnSegment(seg);\n        });\n      }\n\n      this.trigger('ended');\n    }\n  }, {\n    key: \"onVolumeChanged\",\n    value: function onVolumeChanged(segment, newVolumeValue) {\n      this._volume = newVolumeValue;\n      this.trigger('volumechanged', newVolumeValue);\n    }\n  }, {\n    key: \"onSeekedTo\",\n    value: function onSeekedTo(segment, newSeekPosition) {\n      this.trigger('seeked', newSeekPosition);\n    }\n  }, {\n    key: \"onFadeFinished\",\n    value: function onFadeFinished() {\n      this.trigger('fadefinished');\n    }\n  }, {\n    key: \"onPlaybackRateChanged\",\n    value: function onPlaybackRateChanged(segment, newPlaybackRateValue) {\n      this.trigger('playbackratechanged', newPlaybackRateValue);\n    }\n    /**\n     * Private function. Will generate the exports object, which includes all the functions external users\n     * can call, and will copy all public properties from the instance to this object.\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"exportPublicAPI\",\n    value: function exportPublicAPI() {\n      this.exports = {\n        play: this.play.bind(this),\n        pause: this.pause.bind(this),\n        stop: this.stop.bind(this),\n        fade: this.fade.bind(this),\n        seek: this.seek.bind(this),\n        load: this.load.bind(this),\n        unload: this.unload.bind(this),\n        on: this.on.bind(this),\n        once: this.once.bind(this),\n        off: this.off.bind(this)\n      };\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'volume');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'playbackRate');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'loop');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'muted');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'poolSize');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'isPlaying', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'id', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'url', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'state', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'playbackPosition', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'duration', true);\n    }\n  }, {\n    key: \"initializeOptions\",\n    value: function initializeOptions(options, destNode) {\n      // If no id is provided, generate a simple random identifier\n      // eslint-disable-next-line no-magic-numbers\n      this._id = options && options.id || Math.random().toString(36).substr(2, 9); // eslint-disable-line no-magic-numbers\n\n      var poolSize = options && options.poolSize ? options.poolSize : defaultPoolSize;\n      this._segmentPool = new _AudioSegmentPool__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this._context, destNode, poolSize);\n      this._activeSegments = [];\n\n      if (options && typeof options.optimizeFor !== 'undefined' && options.optimizeFor !== 'time' && options.optimizeFor !== 'memory') {\n        throw new Error('options.optimizeFor can either be \"time\" or \"memory\"');\n      }\n\n      this._optimizeFor = options && typeof options.optimizeFor !== 'undefined' ? options.optimizeFor : 'time';\n      this._preload = options && typeof options.preload !== 'undefined' ? options.preload : true;\n      this._state = 'unloaded';\n      this._autoplay = options && options.autoplay || false;\n      this._loop = options && options.loop || false;\n      this._muted = options && options.muted || false;\n      this._volume = options && typeof options.volume !== 'undefined' ? options.volume : 1.0;\n      this._playbackRate = 1.0;\n    }\n    /**\n     * Will attempt to load the buffer from the pre-determined URL and pass it to the given segment.\n     *\n     * @returns\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"loadSegment\",\n    value: function loadSegment(audioSegment) {\n      var _this5 = this;\n\n      audioSegment.volume = this._volume;\n      audioSegment.playbackRate = this._playbackRate;\n      audioSegment.muted = this._muted;\n      audioSegment.loop = this._loop; // Listen to AudioSegment's events\n\n      this.setUpAudioSegmentListeners(audioSegment); // Load the buffer from the URL.\n\n      if (!this._url) {\n        var errMsg = 'Missing valid URL - cannot load';\n        this.trigger('error', errMsg);\n        throw new Error(errMsg);\n      }\n\n      var saveToCache = this._optimizeFor === 'time';\n      return this._decodedBufferCache.getDecodedBuffer(this._url, this._context, saveToCache).then(function (buffer) {\n        audioSegment.load();\n        audioSegment.buffer = buffer;\n\n        if (_this5._state !== 'loaded') {\n          _this5._state = 'loaded';\n\n          _this5.trigger('loaded');\n        }\n      }).catch(function (e) {\n        console.log(e); // eslint-disable-line no-console\n\n        _this5._state = 'unloaded';\n\n        _this5.trigger('error', e);\n      });\n    }\n    /**\n     * Will attempt to load the buffer from the pre-determined URL and pass it to all active audio segments.\n     *\n     * @returns\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this6 = this;\n\n      if (this._state !== 'loaded') {\n        this._state = 'loading';\n      }\n\n      if (this._activeSegments.length === 0) {\n        if (this._segmentPool.canRetrieve()) {\n          var poolSegment = this._segmentPool.retrieve();\n\n          if (poolSegment) {\n            this._activeSegments.push(poolSegment);\n          }\n        }\n      }\n\n      this._activeSegments.forEach(function (segment) {\n        _this6.loadSegment(segment);\n      });\n    }\n    /**\n     * Unloads all active audio segments and removes a ref from the decoded cache\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      var _this7 = this;\n\n      this._state = 'unloaded';\n\n      this._activeSegments.forEach(function (segment) {\n        _this7.removeAudioSegmentListeners(segment);\n\n        _this7._segmentPool.returnSegment(segment);\n      });\n\n      this._activeSegments = [];\n\n      this._decodedBufferCache.removeRef(this._url);\n    }\n  }, {\n    key: \"volume\",\n    get: function get() {\n      return this._volume;\n    },\n    set: function set(newVolumeValue) {\n      this._volume = newVolumeValue;\n\n      this._activeSegments.forEach(function (segment) {\n        segment.volume = newVolumeValue;\n      });\n    }\n    /**\n     * Controls the playback rate of the sound\n     * @name Sonor#playbackRate\n     * @type Number\n     * @default 1.0\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(newPlaybackRateValue) {\n      this._playbackRate = newPlaybackRateValue;\n\n      this._activeSegments.forEach(function (segment) {\n        segment.playbackRate = newPlaybackRateValue;\n      });\n    }\n    /**\n     * Controls if the sound will loop indefinitely or not\n     * @name Sonor#loop\n     * @type Boolean\n     * @default false\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._loop;\n    },\n    set: function set(newIsLooping) {\n      if (newIsLooping === 1) {\n        newIsLooping = true;\n      } else if (newIsLooping === 0) {\n        newIsLooping = false;\n      }\n\n      if (typeof newIsLooping !== 'boolean') {\n        throw new TypeError('Invalid type given to loop setter - expected a boolean.');\n      }\n\n      this._loop = newIsLooping;\n\n      this._activeSegments.forEach(function (segment) {\n        segment.loop = newIsLooping;\n      });\n    }\n    /**\n     * Controls if the sound is muted or not\n     * @name Sonor#muted\n     * @type Boolean\n     * @default false\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"muted\",\n    get: function get() {\n      return this._muted;\n    },\n    set: function set(newMutedValue) {\n      this._muted = newMutedValue;\n\n      this._activeSegments.forEach(function (segment) {\n        segment.muted = newMutedValue;\n      });\n    }\n    /**\n     * Pool size of the sonor. Increasing this will allow you to start playing the same sound multiple times, before the playthrough is finished.\n     *\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"poolSize\",\n    get: function get() {\n      return this._segmentPool.maxSize;\n    },\n    set: function set(newPoolSize) {\n      this._segmentPool.maxSize = newPoolSize;\n    }\n    /**\n     * Duration of the audio will only be available if the sonor is loaded, and a buffer has been created. Otherwise, will return 0.\n     *\n     * @readonly\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (this._activeSegments.length > 0) {\n        return this._activeSegments[0].duration;\n      }\n\n      console.warn('No active segment, duration cannot be determined.'); // eslint-disable-line no-console\n\n      return 0;\n    }\n    /**\n     * The unique ID for this sound object\n     * @name Sonor#id\n     * @type String\n     * @readonly\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * The chosen URL to download for this sound object\n     * @name Sonor#url\n     * @type String\n     * @readonly\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this._url;\n    }\n    /**\n     * Returns true if a sound is currently playing, false otherwise\n     * @name Sonor#isPlaying\n     * @type boolean\n     * @readonly\n     * @memberof Sonor\n     */\n\n  }, {\n    key: \"isPlaying\",\n    get: function get() {\n      var retVal = false;\n\n      if (this._activeSegments.length > 0) {\n        retVal = this._activeSegments.reduce(function (bool, segment) {\n          return bool && segment.isPlaying;\n        }, true);\n      }\n\n      return retVal;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n  }, {\n    key: \"preload\",\n    get: function get() {\n      return this._preload;\n    }\n  }, {\n    key: \"playbackPosition\",\n    get: function get() {\n      if (this._activeSegments.length > 0) {\n        return this._activeSegments[0].getPlayheadPosition();\n      }\n\n      console.warn('No active segments currently'); // eslint-disable-line no-console\n\n      return 0;\n    }\n  }]);\n\n  return Sonor;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Sonor);\n\n//# sourceURL=webpack://Sonorous/./Sonor/Sonor.js?");

/***/ }),

/***/ "./Sonorous.js":
/*!*********************!*\
  !*** ./Sonorous.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AudioContextManager_AudioContextManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AudioContextManager/AudioContextManager */ \"./AudioContextManager/AudioContextManager.js\");\n/* harmony import */ var _Sonor_Sonor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sonor/Sonor */ \"./Sonor/Sonor.js\");\n/* harmony import */ var _utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/copySetterGetterFromInstance */ \"./utils/copySetterGetterFromInstance.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventemitter3 */ \"../node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\n\n\n\nvar Sonorous = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Sonorous.\n   * @memberof Sonorous\n   */\n  function Sonorous() {\n    _classCallCheck(this, Sonorous);\n\n    // Initialize the event emitter\n    this._eventEmitter = new eventemitter3__WEBPACK_IMPORTED_MODULE_3___default.a();\n    this._loaded = false;\n    this.reload();\n\n    if (typeof window !== 'undefined' && window && typeof window.addEventListener === 'function') {\n      window.addEventListener('unload', this.dispose.bind(this));\n      window.addEventListener('pagehide', this.dispose.bind(this));\n    } // Generate the public facing API\n\n\n    this.exportPublicAPI();\n    return this.exports;\n  }\n\n  _createClass(Sonorous, [{\n    key: \"addSonor\",\n\n    /**\n     * Creates and returns a Sonor object. The Sonor object will connect to the master gain node.\n     *\n     * @param {string|string[]|SonorSrc|SonorSrc[]} src - see the documentation of Sonor to learn more about SonorSrc.\n     * @param {object} [options] - *Optional*. See the documentation of Sonor to learn more about the possible options.\n     * @returns {Sonor}\n     * @memberof Sonorous\n     */\n    value: function addSonor(src, options) {\n      if (!this._loaded) {\n        console.warn('Sonorous has not been loaded yet. Please load before adding sonors.'); // eslint-disable-line no-console\n\n        return;\n      }\n\n      var newSonor = new _Sonor_Sonor__WEBPACK_IMPORTED_MODULE_1__[\"default\"](src, this._masterGain, this._context, options);\n      this._sonors[newSonor.id] = newSonor;\n      return newSonor;\n    }\n    /**\n     * Removes a sonor object from the manager. This will unload and destroy the sound, and immediately stop all processes\n     * related to this sound. If an id is passed in that the manager does not recognize, nothing will happen.\n     *\n     * @param {string} id - The id of the Sonor object to remove\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"removeSonor\",\n    value: function removeSonor(id) {\n      if (this._sonors[id]) {\n        var sonorToRemove = this._sonors[id];\n        sonorToRemove.unload();\n        delete this._sonors[id];\n      } else {\n        console.warn('The ID passed in to removeSonor is not recognized. Nothing will happen.'); // eslint-disable-line no-console\n      }\n    }\n    /**\n     * Returns the Sonor object associated with that ID. If no Sonor object with that ID is found, undefined will be returned.\n     *\n     * @param {string} id - the id of the sonor object to get\n     * @returns {Sonor} - the sonor object associated with the passed in id\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(id) {\n      return this._sonors[id];\n    }\n  }, {\n    key: \"has\",\n    value: function has(id) {\n      return this._sonors[id] !== undefined;\n    }\n  }, {\n    key: \"reload\",\n    value: function reload() {\n      // Create/get the AudioContext\n      this._contextManager = _AudioContextManager_AudioContextManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance;\n\n      if (this._contextManager.context.state === 'closed') {\n        this._contextManager.createAudioContext();\n      }\n\n      this._context = this._contextManager.context;\n\n      this._contextManager.on('audiounlocked', this.onAudioUnlocked.bind(this)); // Initialize private variables\n\n\n      this._sonors = {}; // Initialize the masterGain node and connect it to the context's destination\n\n      this._masterGain = this._context.createGain();\n\n      this._masterGain.gain.setValueAtTime(1.0, this._context.currentTime);\n\n      this._masterGain.connect(this._context.destination);\n\n      this._masterVolume = 1.0;\n      this._masterMuted = false;\n      this._loaded = true;\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      var _this = this;\n\n      Object.keys(this._sonors).forEach(function (id) {\n        _this.removeSonor(id);\n      });\n\n      this._masterGain.disconnect();\n\n      this._contextManager.closeCurrentContext();\n\n      this._context = null;\n      this._loaded = false;\n    }\n    /**\n     * Event emitter function that will let a module register a callback for a specified event issued from\n     * the Sonorous.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      this._eventEmitter.on(eventName, callback);\n    }\n    /**\n     * Event emitter function that will let a module remove a callback for a specified event issued from\n     * the Sonorous.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(eventName, callback) {\n      this._eventEmitter.off(eventName, callback);\n    }\n    /**\n     * Event emitter function that will let a module register a callback for a specified event\n     * from the Sonorous. The callback will only be called once, while the event may\n     * be emitted more than once.\n     *\n     * @param {String} eventName\n     * @param {function} callback\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(eventName, callback) {\n      this._eventEmitter.once(eventName, callback);\n    }\n    /**\n     * Will return true if Sonorous is supported in your current web browser.\n     * If web audio is supported and we are able to create an AudioContext,\n     * Sonorous is supported.\n     *\n     * @returns\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"isSupported\",\n    value: function isSupported() {\n      if (this._contextManager) {\n        return this._contextManager.isSupported;\n      }\n\n      return _AudioContextManager_AudioContextManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance.isSupported;\n    } ///////////////////////////\n    // PRIVATE FUNCTIONS\n    //////////////////////////\n\n  }, {\n    key: \"onAudioUnlocked\",\n    value: function onAudioUnlocked() {\n      this._eventEmitter.emit('audiounlocked');\n    }\n  }, {\n    key: \"exportPublicAPI\",\n    value: function exportPublicAPI() {\n      this.exports = {\n        isSupported: this.isSupported.bind(this),\n        reload: this.reload.bind(this),\n        unload: this.unload.bind(this),\n        addSonor: this.addSonor.bind(this),\n        removeSonor: this.removeSonor.bind(this),\n        get: this.get.bind(this),\n        has: this.has.bind(this),\n        on: this.on.bind(this),\n        once: this.once.bind(this),\n        off: this.off.bind(this)\n      };\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'masterVolume');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'muteAll');\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'sonors', true);\n      Object(_utils_copySetterGetterFromInstance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, this.exports, 'ctx', true);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.unload();\n\n      this._contextManager.dispose();\n\n      if (typeof window !== 'undefined' && window && typeof window.removeEventListener === 'function') {\n        window.removeEventListener('unload', this.dispose);\n        window.removeEventListener('pagehide', this.dispose);\n      }\n    }\n  }, {\n    key: \"masterVolume\",\n\n    /**\n     * A property that will adjust the volume for all Sonor objects.\n     *\n     * @name Sonorous#masterVolume\n     * @type {Number}\n     * @memberof Sonorous\n     */\n    get: function get() {\n      return this._masterVolume;\n    },\n    set: function set(newMasterVolume) {\n      if (typeof newMasterVolume !== 'number') {\n        throw new TypeError('Invalid type given to volume setter - expected a number.');\n      } else if (!this._loaded) {\n        console.warn('Sonorous has not been loaded yet. Please load before setting the volume.'); // eslint-disable-line no-console\n\n        return;\n      } else if (newMasterVolume < this._masterGain.gain.minValue || newMasterVolume > this._masterGain.gain.maxValue) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Value (\".concat(newMasterVolume, \") is out of bounds. Clamping to range:\\n            [\").concat(this._masterGain.gain.minValue, \", \").concat(this._masterGain.gain.maxValue, \"]\"));\n        newMasterVolume = Math.min(this._masterGain.gain.maxValue, Math.max(this._masterGain.gain.maxValue, newMasterVolume));\n      }\n\n      this._masterVolume = newMasterVolume;\n\n      this._eventEmitter.emit('mastervolumechanged', newMasterVolume);\n\n      if (!this._masterMuted) {\n        this._masterGain.gain.setValueAtTime(newMasterVolume, this._context.currentTime);\n      }\n    }\n    /**\n     * Mute all Sonor objects.\n     *\n     * @name Sonorous#muteAll\n     * @type {Boolean}\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"muteAll\",\n    get: function get() {\n      return this._masterMuted;\n    },\n    set: function set(newMuteValue) {\n      if (typeof newMuteValue !== 'boolean') {\n        throw new TypeError('Invalid type given to muted setter - expected a boolean.');\n      } else if (!this._loaded) {\n        console.warn('Sonorous has not yet been loaded. Please load Sonorous before setting mute.'); // eslint-disable-line\n\n        return;\n      }\n\n      this._masterMuted = newMuteValue;\n      var volValue = newMuteValue ? 0.0 : this._masterVolume;\n\n      this._eventEmitter.emit('mastervolumechanged', volValue);\n\n      this._masterGain.gain.setValueAtTime(volValue, this._masterGain.context.currentTime);\n    }\n    /**\n     * A read-only array of all Sonor objects added to this manager.\n     *\n     * @name Sonorous#sonors\n     * @type {Sonor[]}\n     * @readonly\n     * @memberof Sonorous\n     */\n\n  }, {\n    key: \"sonors\",\n    get: function get() {\n      var _this2 = this;\n\n      return Object.keys(this._sonors).map(function (id) {\n        return _this2._sonors[id];\n      });\n    }\n  }, {\n    key: \"ctx\",\n    get: function get() {\n      return this._context;\n    }\n  }], [{\n    key: \"instance\",\n    get: function get() {\n      if (!this._instance) {\n        this._instance = new Sonorous();\n      }\n\n      return this._instance;\n    }\n  }]);\n\n  return Sonorous;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Sonorous.instance);\n\n//# sourceURL=webpack://Sonorous/./Sonorous.js?");

/***/ }),

/***/ "./utils/ActionQueue/ActionQueue.js":
/*!******************************************!*\
  !*** ./utils/ActionQueue/ActionQueue.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/**\n * ActionQueue is a simple implementation of an action queue. It allows you to push actions\n * to the queue and once started, will execute them all synchronously. Any actions pushed\n * after the queue has been started will execute immediately. Stopping the queue will\n * prevent actions from executing immediately. It will instead push the actions to the\n * queue and then execute them once the queue has started.\n *\n * @class ActionQueue\n */\nvar ActionQueue = /*#__PURE__*/function () {\n  function ActionQueue() {\n    _classCallCheck(this, ActionQueue);\n\n    this._queue = [];\n    this._started = false;\n    this._debugLog = [];\n  }\n  /**\n   * Will begin executing actions in the queue. The actions will execute synchronously\n   * (even for async operations). Any actions that are pushed after the queue has been\n   * started will execute immediately.\n   *\n   * @memberof ActionQueue\n   */\n\n\n  _createClass(ActionQueue, [{\n    key: \"start\",\n    value: function start() {\n      // eslint-disable-next-line no-negated-condition\n      if (!this._started) {\n        this._started = true;\n\n        this._debugLog.push(\"Queue started\");\n\n        while (!this.isEmpty) {\n          this.pop();\n        }\n      }\n    }\n    /**\n     * Will stop the execution of actions. Any actions pushed after the queue\n     * was stopped will execute when the queue starts again.\n     *\n     * @memberof ActionQueue\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._started = false;\n\n      this._debugLog.push(\"Queue stopped\");\n    }\n    /**\n     * Push an action to the action queue for it to be executed. If the queue has\n     * already started, then the action will be executed immediately. If the queue\n     * is stopped, or has not yet been started, the action will be added to the queue\n     * and will be executed once the queue is started. The actions will execute in the\n     * order they were pushed.\n     *\n     * An action pushed to the queue must have 2 properties- an action name and\n     * an action (function) to be executed.\n     *\n     * @param {object} action - the action to be actionually executed\n     * @param {string} action.name - the name of the action to be executed\n     * @param {function} action.onExecute - the action that will be executed\n     * @param {[*]} action.args - any arguments that should be passed into the action when called\n     * @memberof ActionQueue\n     */\n\n  }, {\n    key: \"push\",\n    value: function push(action) {\n      if (!action.onExecute) {\n        throw new Error('Action must have an onExecute function');\n      }\n\n      if (typeof action.onExecute !== 'function') {\n        throw new TypeError('onExecute must be a function');\n      }\n\n      if (!action.name) {\n        throw new Error('action must have a name');\n      }\n\n      if (typeof action.name !== 'string') {\n        throw new TypeError('action name must be a string');\n      }\n\n      if (action.args && _typeof(action.args) !== 'object') {\n        throw new TypeError('Args must be in an array');\n      }\n\n      this._queue.push(action);\n\n      this._debugLog.push(\"\".concat(action.name, \" added\"));\n\n      this.pop();\n    } // Private Functions\n\n    /**\n     * This will remove an item from the queue and execute its action as long as the queue has started.\n     *\n     * @returns\n     * @memberof ActionQueue\n     */\n\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (!this._started) {\n        return;\n      }\n\n      if (this.size > 0) {\n        var e = this._queue.shift();\n\n        this._debugLog.push(\"\".concat(e.name, \" removed\"));\n\n        if (e.args) {\n          e.onExecute.apply(e, _toConsumableArray(e.args));\n        } else {\n          e.onExecute();\n        }\n      } else {\n        throw new Error('Attempt to pop with no actions in queue');\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._queue = [];\n      this._debugLog = [];\n\n      this._debugLog.push('Queue cleared');\n    }\n  }, {\n    key: \"printLog\",\n    value: function printLog() {\n      this._debugLog.forEach(function (element) {\n        console.log(element); // eslint-disable-line no-console\n      });\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._queue.length === 0;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._queue.length;\n    }\n  }]);\n\n  return ActionQueue;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ActionQueue);\n\n//# sourceURL=webpack://Sonorous/./utils/ActionQueue/ActionQueue.js?");

/***/ }),

/***/ "./utils/copySetterGetterFromInstance.js":
/*!***********************************************!*\
  !*** ./utils/copySetterGetterFromInstance.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Copies a property from an instance onto an object. The object's get/set functions will\n * essentially hook into the instance's get/set functions. This means that manipulating the\n * property on the object will manipulate it on the instance.\n *\n * @param {*} instance - instance to copy the getter/setter from\n * @param {*} object - object to copy the getter/setter to\n * @param {*} propertyName - property name to copy over\n * @param {*} readOnly - should it be read only or not?\n */\nfunction copyGetterSetterFromInstance(instance, object, propertyName, readOnly) {\n  Object.defineProperty(object, propertyName, {\n    get: function get() {\n      return instance[propertyName];\n    },\n    // If we don't want a setter, pass undefined so it won't be settable\n    set: readOnly ? undefined : function (newValue) {\n      instance[propertyName] = newValue;\n    },\n    enumerable: true // Must be enumerable so that extend() catches it\n\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (copyGetterSetterFromInstance);\n\n//# sourceURL=webpack://Sonorous/./utils/copySetterGetterFromInstance.js?");

/***/ }),

/***/ "./utils/environment.js":
/*!******************************!*\
  !*** ./utils/environment.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ua-parser-js */ \"../node_modules/ua-parser-js/src/ua-parser.js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_0__);\n\nvar result = new ua_parser_js__WEBPACK_IMPORTED_MODULE_0___default.a().getResult();\nvar deviceType = result.device && result.device.type && result.device.type.toLowerCase() || '';\nvar os = result.os && result.os.name && result.os.name.toLowerCase() || '';\nvar browser = result.browser && result.browser.name && result.browser.name.toLowerCase() || '';\nvar browserMajVer = result.browser && parseInt(result.browser.major, 10) || 0;\nvar osMajVer = parseInt(os.version, 10) || 0;\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  deviceType: deviceType,\n  os: os,\n  osMajVer: osMajVer,\n  browser: browser,\n  browserMajVer: browserMajVer\n});\n\n//# sourceURL=webpack://Sonorous/./utils/environment.js?");

/***/ }),

/***/ "./utils/formatMap.js":
/*!****************************!*\
  !*** ./utils/formatMap.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./environment */ \"./utils/environment.js\");\n\nvar browser = _environment__WEBPACK_IMPORTED_MODULE_0__[\"default\"].browser;\nvar os = _environment__WEBPACK_IMPORTED_MODULE_0__[\"default\"].os;\nvar isSafariOriOS = browser.indexOf('safari') >= 0 || os === 'ios'; // eslint-disable-next-line no-unused-vars\n\nvar FORMAT_TO_MIMETYPE_CODEC = {\n  mp3: ['audio/mp3;'],\n  opus: ['audio/ogg; codecs=\"opus\"'],\n  ogg: ['audio/ogg; codecs=\"vorbis\"'],\n  oga: ['audio/ogg; codecs=\"vorbis\"'],\n  wav: ['audio/wav; codecs=\"1\"'],\n  aac: ['audio/aac;'],\n  caf: ['audio/x-caf;'],\n  m4a: ['audio/x-m4a;', 'audio/m4a;', 'audio/aac;'],\n  mp4: ['audio/x-mp4;', 'audio/mp4;', 'audio/aac;'],\n  weba: ['audio/webm; codecs=\"vorbis\"'],\n  dolby: ['audio/mp4; codecs=\"ec-3\"'],\n  flac: ['audio/x-flac;', 'audio/flac']\n}; // Bug fix - on Big Sur Safari v14.1, this comes up as supported (\"probably\"), but then decode fails.\n// Let's disable webm_vorbis on all Safari and iOS devices.\n\nif (!isSafariOriOS) {\n  FORMAT_TO_MIMETYPE_CODEC.webm = ['audio/webm; codecs=\"vorbis\"'];\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (FORMAT_TO_MIMETYPE_CODEC);\n\n//# sourceURL=webpack://Sonorous/./utils/formatMap.js?");

/***/ }),

/***/ "./utils/validateSourcesHelper.js":
/*!****************************************!*\
  !*** ./utils/validateSourcesHelper.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_formatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/formatMap */ \"./utils/formatMap.js\");\n\n/**\n * Takes in whatever was passed in as the source url and formats it to an array of SonorSrc objects\n *\n * @param {string|string[]|SonorSrc|SonorSrc[]} srcArray\n * @returns {SonorSrc[]} an array of formatted SonorSrc objects\n * @memberof Sonor\n */\n\nfunction normalizeSrc(srcArray) {\n  // If only one src was passed in, turn it into an array\n  if (!Array.isArray(srcArray)) {\n    srcArray = [srcArray];\n  } // Turn the array into an array of SonorSrc objects\n\n\n  return srcArray.map(function (val) {\n    var formattedSrc = {}; // If there already is a url property and a format, then include the object in the array as is\n\n    if (val.url && val.format) {\n      // Remove the period if one is at the end of the url\n      if (val.url[val.url.length - 1] === '.') {\n        val.url = val.url.slice(0, -1);\n      } // Remove the period if there is one at the beginning of the format\n\n\n      if (val.format[0] === '.') {\n        val.format = val.format.slice(1, -1);\n      }\n\n      formattedSrc = val;\n    } else {\n      // Else, turn val into a 'SonorSrc' object with a url and a format\n      var url = val.url ? val.url : val;\n      var urlExtension = url.split('.').pop();\n      var urlWithoutExtension = url.substr(0, url.lastIndexOf('.')) || url;\n      formattedSrc.url = urlWithoutExtension;\n      formattedSrc.format = urlExtension;\n    }\n\n    return formattedSrc;\n  });\n}\n/**\n * Validates that the src has a valid extension that is supported by this library\n *\n * @param {SonorSrc} src\n * @returns {boolean} true if it is supported, false if it isn't\n * @memberof Sonor\n */\n\n\nfunction isValidSrc(src) {\n  if (!src || !src.format || !src.url) {\n    return false;\n  }\n\n  var mimeTypesAndCodecs = _utils_formatMap__WEBPACK_IMPORTED_MODULE_0__[\"default\"][src.format]; // Didn't find a specified mime type/codec for this format. Can't play it.\n\n  if (!mimeTypesAndCodecs) {\n    return false;\n  }\n\n  var foundCodec = mimeTypesAndCodecs.find(function (val) {\n    // Check to see if the audio file is playable with the current browser\n    var audio = new Audio();\n    var canPlay = audio.canPlayType(val);\n    return canPlay === 'probably' || canPlay === 'maybe';\n  });\n  return foundCodec !== undefined;\n}\n/**\n * Iterates through the list of sources and returns the first valid source.\n *\n * @param {SonorSrc[]} srcArray\n * @returns {SonorSrc} the first valid source, or undefined if there isn't one\n * @memberof Sonor\n */\n\n\nfunction chooseValidURL(srcArray) {\n  var validSonorSrc = srcArray.find(function (val) {\n    return isValidSrc(val);\n  });\n\n  if (validSonorSrc) {\n    return validSonorSrc.url + '.' + validSonorSrc.format;\n  }\n\n  return undefined;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  normalizeSrc: normalizeSrc,\n  isValidSrc: isValidSrc,\n  chooseValidURL: chooseValidURL\n});\n\n//# sourceURL=webpack://Sonorous/./utils/validateSourcesHelper.js?");

/***/ })

/******/ })["default"];
});